<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>ECG Viewer — Unified</title>
<style>
  :root{
    --paper:#fff7f7;
    --trace:#111;
    --grid1:rgba(205,40,40,0.18);
    --grid5:rgba(205,40,40,0.44);
    --text:#141414;
    --muted:#5c5c5c;
    --panel:#ffffff;
    --border:#e2d6d6;
    --btn:#f7f0f0;
    --btn2:#efe3e3;
    --accent:#1b6dff;
    --ok:#0a7a3b;
    --warn:#b00020;
  }
  body{background:#f3f3f3;color:var(--text);font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial;margin:16px;}
  h2{margin:0 0 10px 0;font-weight:650;letter-spacing:0.2px}
  .bar{
    display:flex; gap:10px; flex-wrap:wrap; align-items:center;
    background:var(--panel); border:1px solid var(--border); border-radius:12px;
    padding:10px 12px; margin:10px 0 12px 0;
    box-shadow:0 1px 0 rgba(0,0,0,0.04);
  }
  .welcome{
    display:flex;flex-direction:column;gap:6px;
    background:linear-gradient(135deg,#f8f0f0,#fff7f7);
    border:1px solid var(--border); border-radius:12px;
    padding:12px 14px; margin:10px 0 12px 0;
    box-shadow:0 1px 0 rgba(0,0,0,0.04);
  }
  .welcome .t1{font-weight:700;font-size:15px;}
  .welcome .t2{font-size:13px;color:var(--muted);}
  .hint{font-size:12px;color:var(--muted);}
  .bar label{display:flex; gap:8px; align-items:center; color:var(--muted); font-size:13px}
  select, input[type="file"]{
    background:#fff; color:var(--text); border:1px solid var(--border); border-radius:8px;
    padding:6px 8px; font-size:13px;
  }
  button{
    background:var(--btn); color:var(--text); border:1px solid var(--border); border-radius:10px;
    padding:7px 10px; font-size:13px; cursor:pointer;
  }
  button:hover{background:var(--btn2)}
  .pill{padding:4px 8px;border-radius:999px;background:#fff;border:1px solid var(--border);color:var(--muted);font-size:12px}
  .wrap{border:1px solid var(--border); border-radius:14px; overflow:hidden; background:var(--paper);}
  canvas{display:block; width:100%; height:900px; background:var(--paper);}
  .footer{margin-top:10px;color:var(--muted);font-size:12px;line-height:1.35}
  .grid2{display:grid;grid-template-columns:repeat(6,minmax(140px,1fr));gap:8px;width:100%}
  .kv{background:#fff;border:1px solid var(--border);border-radius:12px;padding:10px 10px;min-height:44px}
  .k{font-size:11px;color:var(--muted);margin-bottom:3px}
  .v{font-size:14px;font-weight:650;color:var(--text)}
  @media (max-width: 980px){
    .grid2{grid-template-columns:repeat(2,minmax(140px,1fr));}
    canvas{height:720px;}
  }
  .masthead{
    display:flex;flex-wrap:wrap;gap:10px;align-items:center;
    background:var(--panel);border:1px solid var(--border);border-radius:12px;
    padding:10px 12px;margin-bottom:10px;
  }
  .tag{
    padding:4px 10px;border-radius:999px;border:1px solid transparent;font-weight:700;font-size:12px;letter-spacing:0.3px;
  }
  .tag-synth{background:#ffe4e8;border-color:#f0b6c0;color:#b00020;}
  .tag-real{background:#e5f7ec;border-color:#b5e1c7;color:#0b6b3b;}
  .tag-unknown{background:#fff4d6;border-color:#f1d08c;color:#8a5a00;}
  .mh-title{font-weight:700;font-size:16px}
  .mh-field{font-size:12px;color:var(--muted)}
  .missing-lead{color:#b00020;}
  .quiz-input input{
    width:80px;padding:6px 8px;border:1px solid var(--border);border-radius:8px;
    font-size:14px;margin-top:4px;
  }
  .quiz-input input:focus{outline:2px solid var(--accent);outline-offset:1px}
  .grade-result{font-size:12px;margin-top:4px;min-height:16px}
  .grade-result.correct{color:var(--ok);font-weight:600}
  .grade-result.close{color:#b8860b;font-weight:600}
  .grade-result.incorrect{color:var(--warn);font-weight:600}
  .quiz-actions{display:flex;flex-direction:column;gap:6px;align-items:flex-start}
  .quiz-actions button{min-width:100px}
  .quiz-score{font-size:14px;font-weight:700;margin-top:4px}
  .quiz-score.perfect{color:var(--ok)}
  .quiz-score.good{color:#b8860b}
  .quiz-score.needs-work{color:var(--warn)}
  .teach-highlight{background:linear-gradient(90deg,rgba(27,109,255,0.08),transparent);border-left:3px solid var(--accent);padding-left:8px}
  @media print{
    body{margin:0;background:white;}
    .bar,.masthead{page-break-inside:avoid;box-shadow:none;}
    button,input,select{display:none !important;}
    .quiz-bar{display:none !important;}
  }
</style>
</head>
<body>
<h2>ECG Viewer — Unified (Stacked + Print + Measurements)</h2>

<div class="welcome">
  <div class="t1">In-browser ECG teaching lab for learners and educators.</div>
  <div class="t2">Accurate measurements + print-quality layouts. Synthetic data is always labeled in-app; exports stay clean (no watermarks) while metadata keeps the synthetic flag.</div>
</div>

<div class="bar mode-bar">
  <label>Mode
    <select id="mode">
      <option value="view" selected>View</option>
      <option value="teach">Teach</option>
      <option value="quiz">Quiz</option>
    </select>
  </label>
  <span class="hint" id="modeHint">View mode: explore ECG with all measurements visible.</span>
  <label>Case Pack
    <select id="casePack">
      <option value="">— None —</option>
      <option value="basics">Basics (HR, rhythm)</option>
      <option value="intervals">Intervals (PR, QRS, QT)</option>
      <option value="axes">Axis determination</option>
    </select>
  </label>
  <button id="prevCase" disabled>◀ Prev</button>
  <span class="pill" id="caseProgress">—</span>
  <button id="nextCase" disabled>Next ▶</button>
  <button id="randomCase">Random Case</button>
  <label>Dx
    <select id="randomDx">
      <option value="">Any</option>
    </select>
  </label>
</div>

<div class="masthead">
  <div class="mh-title" id="mhTitle">Synthetic ECG</div>
  <div class="tag tag-unknown" id="mhSynth">SOURCE UNKNOWN</div>
  <div class="mh-field" id="mhPatient">Patient: —</div>
  <div class="mh-field" id="mhMeta">Age: — • Sex: — • HR target: —</div>
  <div class="mh-field" id="mhWhen">Recorded: —</div>
</div>

<div class="bar">
  <label>Sample
    <select id="sample">
      <option value="../data/ecg_data_v5_world_class.json">World-class sample</option>
      <option value="../data/ecg_data.json">Basic sample</option>
    </select>
  </label>
  <label>Load file
    <input id="fileInput" type="file" accept=".json" />
  </label>
  <label>Layout
    <select id="layout">
      <option value="stacked" selected>Stacked (15 leads)</option>
      <option value="print12">12-lead print + rhythm</option>
    </select>
  </label>
  <span class="hint" id="layoutHint">Stacked view: free speed/gain/scale. Print locks 25 mm/s, 10 mm/mV, clean exports.</span>
  <label>Speed
    <select id="speed">
      <option value="25" selected>25 mm/s</option>
      <option value="50">50 mm/s</option>
    </select>
  </label>
  <label>Gain
    <select id="gain">
      <option value="5">5 mm/mV</option>
      <option value="10" selected>10 mm/mV</option>
      <option value="20">20 mm/mV</option>
    </select>
  </label>
  <label>Paper scale
    <select id="pxmm">
      <option value="4" selected>Fit</option>
      <option value="6">Medium</option>
      <option value="8">Large</option>
    </select>
  </label>
  <label><input id="fid" type="checkbox" checked> Fiducials</label>
  <button id="calBtn">Calipers: OFF</button>
  <button id="clearBtn">Clear</button>
  <span class="pill" id="info">—</span>
  <span class="pill" id="integrityPill">—</span>
  <button id="pngBtn">Export PNG</button>
  <button id="printPngBtn">Export print PNG</button>
  <button id="pdfBtn">Print / PDF</button>
</div>

<div class="bar measurements-bar" id="measurementsBar" style="width:100%">
  <div class="grid2">
    <div class="kv"><div class="k">Ventricular rate</div><div class="v" id="m_hr">—</div></div>
    <div class="kv"><div class="k">PR</div><div class="v" id="m_pr">—</div></div>
    <div class="kv"><div class="k">QRS</div><div class="v" id="m_qrs">—</div></div>
    <div class="kv"><div class="k">QT / QTc (Bazett)</div><div class="v" id="m_qt">—</div></div>
    <div class="kv"><div class="k">Axes (P / QRS / T)</div><div class="v" id="m_axes">—</div></div>
    <div class="kv"><div class="k">Beats used (median)</div><div class="v" id="m_beats">—</div></div>
  </div>
</div>

<div class="bar quiz-bar" id="quizBar" style="width:100%;display:none">
  <div class="grid2">
    <div class="kv quiz-input">
      <div class="k">Ventricular rate (bpm)</div>
      <input type="number" id="q_hr" placeholder="?" min="20" max="300" />
      <div class="grade-result" id="g_hr"></div>
    </div>
    <div class="kv quiz-input">
      <div class="k">PR interval (ms)</div>
      <input type="number" id="q_pr" placeholder="?" min="0" max="500" />
      <div class="grade-result" id="g_pr"></div>
    </div>
    <div class="kv quiz-input">
      <div class="k">QRS duration (ms)</div>
      <input type="number" id="q_qrs" placeholder="?" min="0" max="300" />
      <div class="grade-result" id="g_qrs"></div>
    </div>
    <div class="kv quiz-input">
      <div class="k">QT interval (ms)</div>
      <input type="number" id="q_qt" placeholder="?" min="0" max="700" />
      <div class="grade-result" id="g_qt"></div>
    </div>
    <div class="kv quiz-input">
      <div class="k">QRS axis (degrees)</div>
      <input type="number" id="q_axis" placeholder="?" min="-180" max="180" />
      <div class="grade-result" id="g_axis"></div>
    </div>
    <div class="kv quiz-actions">
      <button id="gradeBtn">Grade Answers</button>
      <button id="revealBtn">Reveal</button>
      <div class="quiz-score" id="quizScore"></div>
    </div>
  </div>
</div>

<div class="bar teach-tips" id="teachTips" style="display:none;flex-direction:column;gap:8px">
  <div style="font-weight:600;font-size:13px;color:var(--accent)">Teaching Tips</div>
  <div id="tipContent" style="font-size:12px;color:var(--muted);line-height:1.5"></div>
</div>

<div class="wrap"><canvas id="c"></canvas></div>
<div class="footer" id="footer"></div>

<script type="module">
import {
  fetchECG,
  normalizeECGData,
  fmtMs, fmtBpm, fmtDeg,
} from "./js/ecg-core.js";
import { synthECG, DIAGNOSES, generateRandomCase } from "./js/ecg-synth.js";

const leads15 = ["I","II","III","aVR","aVL","aVF","V1","V2","V3","V4","V5","V6","V3R","V4R","V7"];
const printGrid = [
  ["I","aVR","V1","V4"],
  ["II","aVL","V2","V5"],
  ["III","aVF","V3","V6"],
];

const canvas = document.getElementById("c");
const ctx = canvas.getContext("2d", {alpha:false});

const elSample = document.getElementById("sample");
const elFile = document.getElementById("fileInput");
const elLayout = document.getElementById("layout");
const elSpeed = document.getElementById("speed");
const elGain = document.getElementById("gain");
const elPxmm = document.getElementById("pxmm");
const elFid = document.getElementById("fid");
const elCal = document.getElementById("calBtn");
const elClear = document.getElementById("clearBtn");
const elInfo = document.getElementById("info");
const elInt = document.getElementById("integrityPill");
const elFooter = document.getElementById("footer");
const elLayoutHint = document.getElementById("layoutHint");

const elHr = document.getElementById("m_hr");
const elPR = document.getElementById("m_pr");
const elQRS = document.getElementById("m_qrs");
const elQT = document.getElementById("m_qt");
const elAxes = document.getElementById("m_axes");
const elBeats = document.getElementById("m_beats");

const elMhTitle = document.getElementById("mhTitle");
const elMhSynth = document.getElementById("mhSynth");
const elMhPatient = document.getElementById("mhPatient");
const elMhMeta = document.getElementById("mhMeta");
const elMhWhen = document.getElementById("mhWhen");
const elPng = document.getElementById("pngBtn");
const elPrintPng = document.getElementById("printPngBtn");
const elPdf = document.getElementById("pdfBtn");

// Mode & Quiz elements
const elMode = document.getElementById("mode");
const elModeHint = document.getElementById("modeHint");
const elMeasurementsBar = document.getElementById("measurementsBar");
const elQuizBar = document.getElementById("quizBar");
const elCasePack = document.getElementById("casePack");
const elPrevCase = document.getElementById("prevCase");
const elNextCase = document.getElementById("nextCase");
const elCaseProgress = document.getElementById("caseProgress");
const elGradeBtn = document.getElementById("gradeBtn");
const elRevealBtn = document.getElementById("revealBtn");
const elQuizScore = document.getElementById("quizScore");
const elRandomCase = document.getElementById("randomCase");
const elRandomDx = document.getElementById("randomDx");
const elTeachTips = document.getElementById("teachTips");
const elTipContent = document.getElementById("tipContent");

// Quiz inputs
const qHr = document.getElementById("q_hr");
const qPr = document.getElementById("q_pr");
const qQrs = document.getElementById("q_qrs");
const qQt = document.getElementById("q_qt");
const qAxis = document.getElementById("q_axis");
const gHr = document.getElementById("g_hr");
const gPr = document.getElementById("g_pr");
const gQrs = document.getElementById("g_qrs");
const gQt = document.getElementById("g_qt");
const gAxis = document.getElementById("g_axis");

let META = null;
let ANALYSIS = null;
let calipers = false;
let pts = [];
let patientId = `P-${Math.floor(Math.random()*90000+10000)}`;
let recordedAt = new Date();

let analysisWorker = null;
let analysisSeq = 0;
let activeAnalysisId = 0;

const PRINT_LOCKS = { speed:25, gain:10, pxmm:6 };

// Case pack definitions
const CASE_PACKS = {
  basics: {
    name: "Basics",
    description: "Learn to measure heart rate and identify basic rhythm",
    cases: [
      { url: "../data/ecg_data_v5_world_class.json", focus: ["hr"], hint: "Count R-R intervals" },
      { url: "../data/ecg_data.json", focus: ["hr"], hint: "Use calipers for precision" },
    ]
  },
  intervals: {
    name: "Intervals",
    description: "Measure PR, QRS, and QT intervals accurately",
    cases: [
      { url: "../data/ecg_data_v5_world_class.json", focus: ["pr", "qrs", "qt"], hint: "PR: P onset to QRS onset" },
      { url: "../data/ecg_data.json", focus: ["pr", "qrs", "qt"], hint: "QT: QRS onset to T-wave end" },
    ]
  },
  axes: {
    name: "Axis Determination",
    description: "Determine the QRS axis using leads I and aVF",
    cases: [
      { url: "../data/ecg_data_v5_world_class.json", focus: ["axis"], hint: "Positive in I and aVF = normal axis" },
      { url: "../data/ecg_data.json", focus: ["axis"], hint: "Use the quadrant method" },
    ]
  }
};

let currentMode = "view";
let currentPack = null;
let currentCaseIdx = 0;
let quizGraded = false;

const MODE_HINTS = {
  view: "View mode: explore ECG with all measurements visible.",
  teach: "Teach mode: measurements visible with educational highlights.",
  quiz: "Quiz mode: enter your measurements, then grade your answers."
};

const TEACHING_TIPS = {
  hr: [
    "Heart rate = 60 / RR interval (in seconds)",
    "Count large boxes between R-peaks: 300/boxes = HR",
    "Normal pediatric HR varies by age: newborn ~140, child ~100, teen ~70",
  ],
  pr: [
    "PR interval: from P-wave onset to QRS onset",
    "Normal PR: 120-200ms in adults, shorter in children",
    "Short PR (<120ms) may indicate WPW or junctional rhythm",
    "Long PR (>200ms) suggests first-degree AV block",
  ],
  qrs: [
    "QRS duration: from Q-wave onset to S-wave end",
    "Normal QRS: <100ms (narrow complex)",
    "Wide QRS (>120ms): bundle branch block, WPW, or ventricular origin",
    "In RBBB, look for RSR' pattern in V1",
  ],
  qt: [
    "QT interval: from QRS onset to T-wave end",
    "QT varies with heart rate - use QTc for comparison",
    "QTc (Bazett) = QT / sqrt(RR)",
    "QTc >460ms in females or >450ms in males is prolonged",
    "Long QT risk: torsades de pointes",
  ],
  axis: [
    "QRS axis: net direction of ventricular depolarization",
    "Quick method: if I and aVF both positive → normal axis (0° to +90°)",
    "Left axis deviation: I positive, aVF negative, axis < -30°",
    "Right axis deviation: I negative, aVF positive, axis > +90°",
    "Pediatric normal axis shifts leftward with age (RVH → LVH pattern)",
  ],
};

function setMode(mode) {
  currentMode = mode;
  elModeHint.textContent = MODE_HINTS[mode] || "";

  if (mode === "quiz") {
    elMeasurementsBar.style.display = "none";
    elQuizBar.style.display = "block";
    elTeachTips.style.display = "none";
    clearQuizInputs();
  } else if (mode === "teach") {
    elMeasurementsBar.style.display = "block";
    elQuizBar.style.display = "none";
    elTeachTips.style.display = "flex";
    elMeasurementsBar.classList.add("teach-highlight");
    showTeachingTips();
  } else {
    elMeasurementsBar.style.display = "block";
    elQuizBar.style.display = "none";
    elTeachTips.style.display = "none";
    elMeasurementsBar.classList.remove("teach-highlight");
  }

  draw();
}

function showTeachingTips() {
  // Collect relevant tips based on current measurements
  const tips = [];

  // Always show basic tips
  tips.push(...TEACHING_TIPS.hr.slice(0, 2));

  if (ANALYSIS && ANALYSIS.measures) {
    const m = ANALYSIS.measures;

    // Add context-specific tips
    if (m.PR != null) {
      if (m.PR < 120) tips.push(TEACHING_TIPS.pr[2]); // Short PR
      else if (m.PR > 200) tips.push(TEACHING_TIPS.pr[3]); // Long PR
      else tips.push(TEACHING_TIPS.pr[0]);
    }

    if (m.QRS != null) {
      if (m.QRS > 120) tips.push(TEACHING_TIPS.qrs[2]); // Wide QRS
      else tips.push(TEACHING_TIPS.qrs[1]);
    }

    if (m.QTcB != null) {
      if (m.QTcB > 460) tips.push(TEACHING_TIPS.qt[4]); // Long QT
      else tips.push(TEACHING_TIPS.qt[2]);
    }

    if (m.axes && m.axes.qAxis != null) {
      const axis = m.axes.qAxis;
      if (axis < -30) tips.push(TEACHING_TIPS.axis[2]); // LAD
      else if (axis > 90) tips.push(TEACHING_TIPS.axis[3]); // RAD
      else tips.push(TEACHING_TIPS.axis[1]); // Normal
    }
  }

  elTipContent.innerHTML = tips.map(t => `• ${t}`).join("<br>");
}

function clearQuizInputs() {
  [qHr, qPr, qQrs, qQt, qAxis].forEach(el => { el.value = ""; });
  [gHr, gPr, gQrs, gQt, gAxis].forEach(el => { el.textContent = ""; el.className = "grade-result"; });
  elQuizScore.textContent = "";
  elQuizScore.className = "quiz-score";
  quizGraded = false;
}

function gradeAnswer(input, actual, tolerance, resultEl) {
  const userVal = parseFloat(input.value);
  if (isNaN(userVal) || actual == null || !isFinite(actual)) {
    resultEl.textContent = actual != null ? `Answer: ${Math.round(actual)}` : "N/A";
    resultEl.className = "grade-result";
    return null;
  }

  const diff = Math.abs(userVal - actual);
  const pctDiff = (diff / Math.abs(actual)) * 100;

  if (diff <= tolerance) {
    resultEl.textContent = `Correct! (${Math.round(actual)})`;
    resultEl.className = "grade-result correct";
    return 1;
  } else if (diff <= tolerance * 2 || pctDiff <= 15) {
    resultEl.textContent = `Close (${Math.round(actual)})`;
    resultEl.className = "grade-result close";
    return 0.5;
  } else {
    resultEl.textContent = `${Math.round(actual)} (off by ${Math.round(diff)})`;
    resultEl.className = "grade-result incorrect";
    return 0;
  }
}

function gradeQuiz() {
  if (!ANALYSIS || !ANALYSIS.measures) {
    elQuizScore.textContent = "No analysis available";
    return;
  }

  const m = ANALYSIS.measures;
  let total = 0, maxScore = 0;

  // HR: tolerance 5 bpm
  const hrScore = gradeAnswer(qHr, m.hr, 5, gHr);
  if (hrScore !== null) { total += hrScore; maxScore++; }

  // PR: tolerance 20ms
  const prScore = gradeAnswer(qPr, m.PR, 20, gPr);
  if (prScore !== null) { total += prScore; maxScore++; }

  // QRS: tolerance 10ms
  const qrsScore = gradeAnswer(qQrs, m.QRS, 10, gQrs);
  if (qrsScore !== null) { total += qrsScore; maxScore++; }

  // QT: tolerance 20ms
  const qtScore = gradeAnswer(qQt, m.QT, 20, gQt);
  if (qtScore !== null) { total += qtScore; maxScore++; }

  // Axis: tolerance 15 degrees
  const axisScore = gradeAnswer(qAxis, m.axes?.qAxis, 15, gAxis);
  if (axisScore !== null) { total += axisScore; maxScore++; }

  const pct = maxScore > 0 ? Math.round((total / maxScore) * 100) : 0;
  elQuizScore.textContent = `Score: ${pct}% (${total}/${maxScore})`;

  if (pct >= 90) {
    elQuizScore.className = "quiz-score perfect";
  } else if (pct >= 70) {
    elQuizScore.className = "quiz-score good";
  } else {
    elQuizScore.className = "quiz-score needs-work";
  }

  quizGraded = true;
}

function revealAnswers() {
  if (!ANALYSIS || !ANALYSIS.measures) return;
  const m = ANALYSIS.measures;

  gHr.textContent = m.hr != null ? `${Math.round(m.hr)} bpm` : "N/A";
  gPr.textContent = m.PR != null ? `${Math.round(m.PR)} ms` : "N/A";
  gQrs.textContent = m.QRS != null ? `${Math.round(m.QRS)} ms` : "N/A";
  gQt.textContent = m.QT != null ? `${Math.round(m.QT)} ms` : "N/A";
  gAxis.textContent = m.axes?.qAxis != null ? `${Math.round(m.axes.qAxis)}°` : "N/A";

  [gHr, gPr, gQrs, gQt, gAxis].forEach(el => el.className = "grade-result");
}

function loadCasePack(packId) {
  if (!packId || !CASE_PACKS[packId]) {
    currentPack = null;
    currentCaseIdx = 0;
    elPrevCase.disabled = true;
    elNextCase.disabled = true;
    elCaseProgress.textContent = "—";
    return;
  }

  currentPack = CASE_PACKS[packId];
  currentCaseIdx = 0;
  updateCaseNav();
  loadCurrentCase();
}

function updateCaseNav() {
  if (!currentPack) {
    elPrevCase.disabled = true;
    elNextCase.disabled = true;
    elCaseProgress.textContent = "—";
    return;
  }

  elPrevCase.disabled = currentCaseIdx === 0;
  elNextCase.disabled = currentCaseIdx >= currentPack.cases.length - 1;
  elCaseProgress.textContent = `Case ${currentCaseIdx + 1}/${currentPack.cases.length}`;
}

function loadCurrentCase() {
  if (!currentPack || !currentPack.cases[currentCaseIdx]) return;

  const caseData = currentPack.cases[currentCaseIdx];
  clearQuizInputs();
  loadSample(caseData.url);

  if (caseData.hint && currentMode === "quiz") {
    elFooter.textContent = `Hint: ${caseData.hint}`;
  }
}

function generateNewCase() {
  const selectedDx = elRandomDx.value;
  const dx = selectedDx || DIAGNOSES[Math.floor(Math.random() * DIAGNOSES.length)];
  const age = Math.random() * 16; // 0-16 years (pediatric focus)
  const seed = Math.floor(Math.random() * 100000) + 1;

  try {
    const ecgData = synthECG(age, dx, seed, true, true);
    META = normalizeECGData(ecgData);
    patientId = `P-${Math.floor(Math.random() * 90000 + 10000)}`;
    recordedAt = new Date();
    clearQuizInputs();
    requestAnalysis(META);
    updateMetrics();
    draw();
    elInfo.textContent = `Generated: ${dx}, age ${age.toFixed(1)}y, seed ${seed}`;

    if (currentMode === "quiz") {
      elFooter.textContent = `New case: ${dx} pattern. Measure the intervals!`;
    }
  } catch (err) {
    elInfo.textContent = `Generation failed: ${err.message}`;
    console.error(err);
  }
}

// Populate diagnosis dropdown
function populateDxDropdown() {
  for (const dx of DIAGNOSES) {
    const opt = document.createElement("option");
    opt.value = dx;
    opt.textContent = dx;
    elRandomDx.appendChild(opt);
  }
}

function ensureAnalysisWorker(){
  if(analysisWorker) return analysisWorker;
  try{
    analysisWorker = new Worker(new URL("./js/ecg-worker.js", import.meta.url), { type:"module" });
    analysisWorker.onmessage = (evt)=>{
      const msg = evt.data || {};
      if(msg.id !== activeAnalysisId) return; // ignore stale
      if(!msg.ok){
        ANALYSIS = null;
        elFooter.textContent = `Analysis failed: ${msg.error || "unknown error"}`;
        return;
      }
      const r = msg.result;
      META.integrity = { ...(r.integrity || {}), ...(META.integrity || {}) };
      ANALYSIS = {
        rPeaks: r.rPeaks,
        medBeat: r.medBeat,
        medFids: r.medianFiducials,
        medFull: r.fiducials,
        measures: r.measures,
        warnings: r.warnings || [],
        errors: r.errors || [],
      };
      updateMetrics();
      draw();
      if(ANALYSIS.errors.length){
        elFooter.textContent = `Validation errors: ${ANALYSIS.errors.join(" • ")}`;
      } else if(ANALYSIS.warnings.length){
        elFooter.textContent = `Warnings: ${ANALYSIS.warnings.join(" • ")}`;
      } else {
        elFooter.textContent = "";
      }
    };
    analysisWorker.onerror = (err)=>{
      ANALYSIS = null;
      elFooter.textContent = `Worker error: ${err?.message || err}`;
    };
  }catch(err){
    analysisWorker = null;
    elFooter.textContent = `Worker unavailable: ${err?.message || err}`;
  }
  return analysisWorker;
}

function requestAnalysis(meta){
  const w = ensureAnalysisWorker();
  if(!w){
    ANALYSIS = null;
    updateMetrics();
    return;
  }
  const id = ++analysisSeq;
  activeAnalysisId = id;
  ANALYSIS = null;
  updateMetrics();
  w.postMessage({ id, type:"analyze", payload: meta });
}

function resizeCanvas(){
  const cssW = canvas.clientWidth || 1200;
  const cssH = canvas.clientHeight || 900;
  const dpr = window.devicePixelRatio || 1;
  canvas.width = Math.floor(cssW * dpr);
  canvas.height = Math.floor(cssH * dpr);
  ctx.setTransform(dpr,0,0,dpr,0,0);
}

function isPrintLayout(){ return elLayout.value === "print12"; }
function pxPerMm(){ return isPrintLayout() ? PRINT_LOCKS.pxmm : +elPxmm.value; }
function speed(){ return isPrintLayout() ? PRINT_LOCKS.speed : +elSpeed.value; }
function gain(){ return isPrintLayout() ? PRINT_LOCKS.gain : +elGain.value; }
function pxPerSec(){ return speed()*pxPerMm(); }
function pxPerUv(){ return (gain()*pxPerMm())/1000.0; }
function cssSize(){ return { w: canvas.clientWidth || canvas.width, h: canvas.clientHeight || canvas.height }; }
function syntheticState(meta){
  const flag = meta?.targets?.synthetic;
  if(flag === true) return { label:"SYNTHETIC", cls:"tag-synth", kind:"synthetic" };
  if(flag === false) return { label:"REAL DATA", cls:"tag-real", kind:"real" };
  return { label:"SOURCE UNKNOWN", cls:"tag-unknown", kind:"unknown" };
}
const synthBadgeStyles = {
  synthetic:{ bg:"rgba(255,228,232,0.9)", fg:"#b00020", border:"#f0b6c0" },
  real:{ bg:"rgba(229,247,236,0.9)", fg:"#0b6b3b", border:"#b5e1c7" },
  unknown:{ bg:"rgba(255,244,214,0.92)", fg:"#8a5a00", border:"#f1d08c" },
};

function syncControlLocks(){
  const locked = isPrintLayout();
  [elSpeed, elGain, elPxmm].forEach((el)=>{
    el.disabled = locked;
  });
  if(locked){
    elSpeed.value = String(PRINT_LOCKS.speed);
    elGain.value = String(PRINT_LOCKS.gain);
    elPxmm.value = String(PRINT_LOCKS.pxmm);
  }
}

function drawGrid(){
  const {w,h} = cssSize();
  const p = pxPerMm();
  ctx.clearRect(0,0,w,h);
  ctx.lineWidth=1;
  ctx.strokeStyle=getComputedStyle(document.documentElement).getPropertyValue("--grid1");
  ctx.beginPath();
  for(let x=0;x<=w;x+=p){ ctx.moveTo(x,0); ctx.lineTo(x,h); }
  for(let y=0;y<=h;y+=p){ ctx.moveTo(0,y); ctx.lineTo(w,y); }
  ctx.stroke();
  ctx.strokeStyle=getComputedStyle(document.documentElement).getPropertyValue("--grid5");
  ctx.beginPath();
  for(let x=0;x<=w;x+=p*5){ ctx.moveTo(x,0); ctx.lineTo(x,h); }
  for(let y=0;y<=h;y+=p*5){ ctx.moveTo(0,y); ctx.lineTo(w,y); }
  ctx.stroke();
}

function drawCalibration(x0,y0){
  const p = pxPerMm();
  ctx.strokeStyle="#111";
  ctx.beginPath();
  ctx.moveTo(x0,y0);
  ctx.lineTo(x0,y0-10*p);
  ctx.lineTo(x0+0.2*pxPerSec(), y0-10*p);
  ctx.lineTo(x0+0.2*pxPerSec(), y0);
  ctx.stroke();
}

function drawMissingLead(lead, baseY, left, width){
  ctx.save();
  ctx.strokeStyle="#c74a4a";
  ctx.setLineDash([6,4]);
  ctx.beginPath();
  ctx.moveTo(left, baseY);
  ctx.lineTo(left + Math.max(60, width - left - 30), baseY);
  ctx.stroke();
  ctx.setLineDash([]);
  ctx.fillStyle="#b00020";
  ctx.fillText(`${lead} missing`, 10, baseY+4);
  ctx.restore();
}

function drawFidsOnLead(baseY, left, leadData){
  if(!elFid.checked || !ANALYSIS || !ANALYSIS.medFull) return;
  const pps = pxPerSec();
  const fs = META.fs;
  ctx.strokeStyle = "rgba(27,109,255,0.8)";
  ctx.lineWidth = 1;
  ctx.beginPath();
  ANALYSIS.medFull.rPeaks.forEach(r=>{
    const x = left + (r/fs)*pps;
    ctx.moveTo(x, baseY-22);
    ctx.lineTo(x, baseY+22);
  });
  ANALYSIS.medFull.qOn.forEach(q=>{
    if(q==null) return;
    const x = left + (q/fs)*pps;
    ctx.moveTo(x, baseY-18); ctx.lineTo(x, baseY+18);
  });
  ANALYSIS.medFull.qOff.forEach(q=>{
    if(q==null) return;
    const x = left + (q/fs)*pps;
    ctx.moveTo(x, baseY-18); ctx.lineTo(x, baseY+18);
  });
  ctx.stroke();
}

function drawStacked(){
  const fs = META.fs;
  const pps = pxPerSec();
  const ppu = pxPerUv();
  const hLead = 60;
  const left = 50;
  const top = 40;
  const step = Math.max(1, Math.floor(fs / pps));
  const {w} = cssSize();
  drawCalibration(left, top + hLead/2);
  let y = top;
  for(const lead of leads15){
    const base = y + hLead/2;
    const data = META.leads_uV[lead];
    ctx.fillStyle="#444";
    ctx.fillText(lead, 10, base+4);
    if(!data){
      drawMissingLead(lead, base, left, w);
      y += hLead;
      continue;
    }
    ctx.beginPath();
    for(let i=0;i<data.length;i+=step){
      const x = left + (i/fs)*pps;
      const yy = base - data[i]*ppu;
      if(i===0) ctx.moveTo(x,yy); else ctx.lineTo(x,yy);
    }
    ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue("--trace");
    ctx.stroke();
    if(lead==="II") drawFidsOnLead(base, left, data);
    y += hLead;
  }
}

function drawPrint12(){
  const fs = META.fs;
  const pps = pxPerSec();
  const ppu = pxPerUv();
  const {w,h} = cssSize();
  const leftPad = 30;
  const topPad = 30;
  const cols = 4, rows = 3;
  const cellW = (w - leftPad*2)/cols;
  const cellH = (h - topPad*2)/rows;
  const step = Math.max(1, Math.floor(fs / pps));

  drawCalibration(leftPad + 6, topPad + cellH - 10);

  for(let r=0;r<rows;r++){
    for(let c=0;c<cols;c++){
      const lead = printGrid[r][c];
      const x0 = leftPad + c*cellW;
      const y0 = topPad + r*cellH;
      const base = y0 + cellH/2;
      const data = META.leads_uV[lead];
      if(!data){
        drawMissingLead(lead, base, x0, x0 + cellW);
        continue;
      }
      ctx.beginPath();
      for(let i=0;i<data.length;i+=step){
        const x = x0 + (i/fs)*pps;
        const y = base - data[i]*ppu;
        if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
      }
      ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue("--trace");
      ctx.stroke();
      ctx.fillStyle="#444";
      ctx.fillText(lead, x0+6, y0+14);
      if(lead==="II") drawFidsOnLead(base, x0, data);
    }
  }
  const left = leftPad;
  const right = leftPad + cellW*3;
  const base = topPad + rows*cellH - cellH*0.35;
  const rhythmLead = META.leads_uV.II;
  if(!rhythmLead){
    drawMissingLead("II rhythm", base, left, right);
    return;
  }
  ctx.beginPath();
  const stepR = Math.max(1, Math.floor(fs / pps));
  for(let i=0;i<rhythmLead.length;i+=stepR){
    const x = left + (i/fs)*pps;
    if(x>right) break;
    const y = base - rhythmLead[i]*ppu;
    if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
  }
  ctx.stroke();
  ctx.fillText("II rhythm", left+6, base - 10);
}

function drawCalipers(){
  if(!calipers || pts.length===0) return;
  ctx.strokeStyle= getComputedStyle(document.documentElement).getPropertyValue("--accent");
  ctx.fillStyle= ctx.strokeStyle;
  ctx.beginPath();
  for(const p of pts){
    ctx.moveTo(p.x-4,p.y); ctx.lineTo(p.x+4,p.y);
    ctx.moveTo(p.x,p.y-4); ctx.lineTo(p.x,p.y+4);
  }
  if(pts.length===2){
    ctx.moveTo(pts[0].x, pts[0].y);
    ctx.lineTo(pts[1].x, pts[1].y);
    const dt = Math.abs(pts[1].x - pts[0].x) / pxPerSec();
    ctx.stroke();
    ctx.fillText(`${Math.round(dt*1000)} ms`, (pts[0].x+pts[1].x)/2, Math.min(pts[0].y, pts[1].y)-6);
  } else {
    ctx.stroke();
  }
}

function drawSyntheticBadge(){
  if(!META) return;
  const state = syntheticState(META);
  const style = synthBadgeStyles[state.kind] || synthBadgeStyles.unknown;
  const {w} = cssSize();
  ctx.save();
  ctx.font = "bold 12px system-ui,-apple-system,Segoe UI,Roboto,Arial";
  const textW = ctx.measureText(state.label).width;
  const padX = 10, padY = 6;
  const boxW = textW + padX*2;
  const boxH = 22;
  const x = w - boxW - 14;
  const y = 14;
  ctx.fillStyle = style.bg;
  ctx.strokeStyle = style.border;
  ctx.lineWidth = 1;
  if(ctx.roundRect){ ctx.beginPath(); ctx.roundRect(x,y,boxW,boxH,8); ctx.fill(); ctx.stroke(); }
  else { ctx.fillRect(x,y,boxW,boxH); ctx.strokeRect(x,y,boxW,boxH); }
  ctx.fillStyle = style.fg;
  ctx.fillText(state.label, x + padX, y + boxH - padY);
  ctx.restore();
}

function draw(){
  if(!META) return;
  resizeCanvas();
  drawGrid();
  if(isPrintLayout()) drawPrint12(); else drawStacked();
  drawCalipers();
  drawSyntheticBadge();
  const locked = isPrintLayout();
  const msg = `${speed()} mm/s • ${gain()} mm/mV • ${pxPerMm()} px/mm${locked ? " (print locked)" : ""}`;
  elInfo.textContent = msg;
}

function updateMetrics(){
  const t = META?.targets || {};
  elMhTitle.textContent = t.dx || "ECG";
  const synth = syntheticState(META);
  elMhSynth.textContent = synth.label;
  elMhSynth.className = `tag ${synth.cls}`;
  elMhPatient.textContent = `Patient: ${patientId}`;
  const age = t.age_years!=null ? `${t.age_years}y` : "—";
  const sex = t.sex || "—";
  const hrTarget = t.HR_bpm ? `${t.HR_bpm} bpm` : "—";
  elMhMeta.textContent = `Age: ${age} • Sex: ${sex} • HR target: ${hrTarget}`;
  elMhWhen.textContent = `Recorded: ${recordedAt.toLocaleString()}`;

  const integ = META?.integrity || {};
  const ein = integ.einthoven_max_abs_error_uV;
  elInt.textContent = (ein!=null) ? `Einthoven err ≤ ${ein} µV` : "Integrity unknown";
  elInt.style.color = (ein!=null && ein < 50) ? "var(--ok)" : "var(--warn)";

  if(!ANALYSIS || !ANALYSIS.measures){
    elHr.textContent=elPR.textContent=elQRS.textContent=elQT.textContent=elAxes.textContent=elBeats.textContent="—";
    return;
  }
  const m = ANALYSIS.measures || {};
  elHr.textContent = fmtBpm(m.hr);
  elPR.textContent = fmtMs(m.PR);
  elQRS.textContent = fmtMs(m.QRS);
  elQT.textContent = (m.QT==null) ? "—" : `${fmtMs(m.QT)} / ${fmtMs(m.QTcB)}`;
  elAxes.textContent = (m.axes && (m.axes.pAxis!=null || m.axes.qAxis!=null || m.axes.tAxis!=null))
    ? `${fmtDeg(m.axes.pAxis)} / ${fmtDeg(m.axes.qAxis)} / ${fmtDeg(m.axes.tAxis)}`
    : "—";
  const beatsUsed = (ANALYSIS.medBeat && ANALYSIS.medBeat.beatsUsed) || "—";
  elBeats.textContent = beatsUsed;

  // Update teaching tips if in teach mode
  if (currentMode === "teach") {
    showTeachingTips();
  }
}

async function loadSample(url){
  elInfo.textContent = "Loading…";
  const meta = await fetchECG(url);
  meta.targets = { ...(meta.targets || {}), synthetic: meta.targets?.synthetic ?? true };
  META = meta;
  recordedAt = new Date();
  requestAnalysis(META);
  updateMetrics();
  draw();
}

function loadFromFile(file){
  const reader = new FileReader();
  reader.onload = ()=>{
    try{
      const raw = JSON.parse(reader.result);
      const meta = normalizeECGData(raw);
      META = meta;
      recordedAt = new Date();
      requestAnalysis(META);
      updateMetrics();
      draw();
      elInfo.textContent = `Loaded ${file.name}`;
    }catch(err){
      elInfo.textContent = "Failed to load file";
      console.error(err);
    }
  };
  reader.readAsText(file);
}

canvas.addEventListener("click",(e)=>{
  if(!calipers) return;
  const r = canvas.getBoundingClientRect();
  pts.push({x:e.clientX - r.left, y:e.clientY - r.top});
  if(pts.length>2) pts = pts.slice(-2);
  draw();
});

document.addEventListener("keydown",(e)=>{
  if(e.key.toLowerCase()==="c"){
    calipers=!calipers;
    elCal.textContent = `Calipers: ${calipers?"ON":"OFF"}`;
  }
});

elCal.onclick = ()=>{ calipers=!calipers; elCal.textContent = `Calipers: ${calipers?"ON":"OFF"}`; draw(); };
elClear.onclick = ()=>{ pts=[]; draw(); };
elLayout.onchange = ()=>{ syncControlLocks(); draw(); };
elSpeed.onchange = draw;
elGain.onchange = draw;
elPxmm.onchange = draw;
elFid.onchange = draw;
window.addEventListener("resize", draw);

elSample.onchange = ()=> loadSample(elSample.value);
elFile.onchange = ()=>{ if(elFile.files && elFile.files[0]) loadFromFile(elFile.files[0]); };

// Mode & Quiz event listeners
elMode.onchange = ()=> setMode(elMode.value);
elGradeBtn.onclick = gradeQuiz;
elRevealBtn.onclick = revealAnswers;
elCasePack.onchange = ()=> loadCasePack(elCasePack.value);
elPrevCase.onclick = ()=>{
  if(currentCaseIdx > 0){
    currentCaseIdx--;
    updateCaseNav();
    loadCurrentCase();
  }
};
elNextCase.onclick = ()=>{
  if(currentPack && currentCaseIdx < currentPack.cases.length - 1){
    currentCaseIdx++;
    updateCaseNav();
    loadCurrentCase();
  }
};
elRandomCase.onclick = generateNewCase;

function exportPrintSnapshot(){
  if(!META) return;
  const prevLayout = elLayout.value;
  const prevSpeed = elSpeed.value;
  const prevGain = elGain.value;
  const prevPxmm = elPxmm.value;
  const prevW = canvas.style.width;
  const prevH = canvas.style.height;

  elLayout.value = "print12";
  syncControlLocks();
  canvas.style.width = "1600px";
  canvas.style.height = "1200px";
  draw();

  const url = canvas.toDataURL("image/png");
  const a = document.createElement("a");
  a.href = url;
  a.download = "ecg_print.png";
  a.click();

  canvas.style.width = prevW;
  canvas.style.height = prevH;
  elLayout.value = prevLayout;
  elSpeed.value = prevSpeed;
  elGain.value = prevGain;
  elPxmm.value = prevPxmm;
  syncControlLocks();
  draw();
}

elPng.onclick = ()=>{
  if(!META) return;
  const url = canvas.toDataURL("image/png");
  const a = document.createElement("a");
  a.href = url;
  a.download = "ecg_viewer.png";
  a.click();
};

elPrintPng.onclick = exportPrintSnapshot;
elPdf.onclick = ()=>{
  window.print();
};

syncControlLocks();
populateDxDropdown();
loadSample(elSample.value).catch(err=>{
  console.error(err);
  elInfo.textContent = "Failed to load sample";
});
</script>
</body>
</html>
