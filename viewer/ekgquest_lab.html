<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>EKGQuest Lab â€” Teaching ECG Laboratory</title>
<style>
  :root {
    --paper: #fef9f5;
    --paper-dark: #fdf5ee;
    --trace: #1a1a1a;
    --grid1: rgba(190,50,50,0.22);
    --grid5: rgba(180,40,40,0.52);
    --text: #141414;
    --muted: #5c5c5c;
    --panel: #ffffff;
    --border: #e2d6d6;
    --btn: #f7f0f0;
    --btn2: #efe3e3;
    --accent: #1b6dff;
    --ok: #0a7a3b;
    --warn: #b00020;
    --chip: #faf6f6;
    --quiz-bg: #fff8e6;
    --quiz-border: #f0d88c;
    --teach-bg: #e8f4ff;
    --teach-border: #a0c8f0;
  }

  /* Clinical ECG font stack - prefer monospace for measurements */
  @font-face {
    font-family: 'ECG';
    src: local('Courier New'), local('Consolas'), local('Liberation Mono');
  }

  * { box-sizing: border-box; }
  body {
    background: #f3f3f3;
    color: var(--text);
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    margin: 0;
    padding: 16px;
  }

  /* Clinical monospace for ECG labels and measurements */
  .ecg-label, .metric-value, #caseInfo {
    font-family: 'Courier New', Consolas, 'Liberation Mono', monospace;
    letter-spacing: -0.5px;
  }

  /* Header */
  .header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 16px;
    margin-bottom: 12px;
    flex-wrap: wrap;
  }
  .header h1 {
    margin: 0;
    font-size: 22px;
    font-weight: 700;
    letter-spacing: -0.3px;
  }
  .header-badge {
    padding: 4px 10px;
    border-radius: 999px;
    font-size: 11px;
    font-weight: 600;
    letter-spacing: 0.3px;
  }
  .badge-synth { background: #ffe4e8; border: 1px solid #f0b6c0; color: #b00020; }
  .badge-real { background: #e5f7ec; border: 1px solid #b5e1c7; color: #0b6b3b; }
  .header-info {
    font-size: 12px;
    color: var(--muted);
    display: flex;
    flex-direction: column;
    gap: 4px;
  }

  /* Status messages */
  .status-msg {
    font-size: 11px;
    padding: 4px 8px;
    border-radius: 4px;
    display: none;
  }
  .status-msg.visible { display: inline-block; }
  .status-msg.error {
    background: #fee2e2;
    color: #b91c1c;
    border: 1px solid #fecaca;
  }
  .status-msg.success {
    background: #dcfce7;
    color: #166534;
    border: 1px solid #bbf7d0;
  }
  .status-msg.info {
    background: #dbeafe;
    color: #1e40af;
    border: 1px solid #bfdbfe;
  }

  /* Mode Toggle */
  .mode-toggle {
    display: flex;
    gap: 0;
    background: var(--panel);
    border: 2px solid var(--border);
    border-radius: 12px;
    padding: 4px;
    box-shadow: 0 2px 8px rgba(0,0,0,0.06);
  }
  .mode-btn {
    padding: 10px 24px;
    border: none;
    border-radius: 8px;
    font-size: 14px;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.15s;
    background: transparent;
    color: var(--muted);
  }
  .mode-btn:hover { background: var(--btn); }
  .mode-btn.active-quiz {
    background: var(--quiz-bg);
    color: #8a5a00;
    box-shadow: 0 2px 4px rgba(0,0,0,0.08);
  }
  .mode-btn.active-teach {
    background: var(--teach-bg);
    color: #1b5a8a;
    box-shadow: 0 2px 4px rgba(0,0,0,0.08);
  }

  /* Reveal Button */
  .reveal-btn {
    display: none;
    padding: 10px 28px;
    background: linear-gradient(135deg, #ff9500, #ff6b00);
    color: white;
    border: none;
    border-radius: 10px;
    font-size: 15px;
    font-weight: 700;
    cursor: pointer;
    box-shadow: 0 3px 12px rgba(255,107,0,0.3);
    transition: all 0.15s;
  }
  .reveal-btn:hover {
    transform: translateY(-1px);
    box-shadow: 0 4px 16px rgba(255,107,0,0.4);
  }
  .reveal-btn.visible { display: block; }

  /* Tabs */
  .tabs {
    display: flex;
    gap: 4px;
    background: var(--panel);
    border: 1px solid var(--border);
    border-radius: 12px 12px 0 0;
    padding: 8px 8px 0 8px;
    margin-top: 12px;
  }
  .tab {
    padding: 10px 20px;
    border: none;
    border-radius: 8px 8px 0 0;
    font-size: 13px;
    font-weight: 600;
    cursor: pointer;
    background: transparent;
    color: var(--muted);
    border-bottom: 2px solid transparent;
    margin-bottom: -1px;
  }
  .tab:hover { background: var(--btn); }
  .tab.active {
    background: var(--paper);
    color: var(--text);
    border-bottom: 2px solid var(--paper);
  }

  /* Tab Panels */
  .tab-panels {
    background: var(--panel);
    border: 1px solid var(--border);
    border-top: none;
    border-radius: 0 0 12px 12px;
    padding: 12px;
  }
  .tab-panel {
    display: none;
    gap: 12px;
    flex-wrap: wrap;
    align-items: center;
  }
  .tab-panel.active { display: flex; }

  /* Form Controls */
  label {
    display: flex;
    gap: 8px;
    align-items: center;
    color: var(--muted);
    font-size: 13px;
  }
  select, input[type="number"], input[type="file"] {
    background: #fff;
    color: var(--text);
    border: 1px solid var(--border);
    border-radius: 8px;
    padding: 6px 10px;
    font-size: 13px;
  }
  input[type="number"] { width: 80px; }
  input[type="checkbox"] { width: 16px; height: 16px; }
  button {
    background: var(--btn);
    color: var(--text);
    border: 1px solid var(--border);
    border-radius: 10px;
    padding: 8px 14px;
    font-size: 13px;
    cursor: pointer;
    font-weight: 500;
  }
  button:hover { background: var(--btn2); }
  button.primary {
    background: var(--accent);
    color: white;
    border-color: var(--accent);
  }
  button.primary:hover { background: #1558cc; }

  .hint { color: var(--muted); font-size: 12px; }
  .divider { width: 1px; height: 28px; background: var(--border); margin: 0 4px; }

  /* Measurements Panel */
  .measurements {
    background: var(--panel);
    border: 1px solid var(--border);
    border-radius: 12px;
    padding: 12px;
    margin-top: 12px;
    transition: opacity 0.2s, max-height 0.3s;
  }
  .measurements.hidden {
    opacity: 0.3;
    max-height: 60px;
    overflow: hidden;
    position: relative;
  }
  .measurements.hidden::after {
    content: "Measurements hidden in Quiz mode";
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: var(--quiz-bg);
    border: 1px solid var(--quiz-border);
    padding: 8px 16px;
    border-radius: 8px;
    font-size: 13px;
    font-weight: 600;
    color: #8a5a00;
  }
  .measurements-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(160px, 1fr));
    gap: 8px;
  }
  .metric {
    background: #fff;
    border: 1px solid var(--border);
    border-radius: 10px;
    padding: 10px;
  }
  .metric-label {
    font-size: 11px;
    color: var(--muted);
    margin-bottom: 4px;
  }
  .metric-value {
    font-size: 14px;
    font-weight: 650;
    color: var(--text);
  }
  .metric-value small { font-weight: 500; color: var(--muted); }
  .ok { color: var(--ok); }
  .bad { color: var(--warn); }

  /* ECG Canvas */
  .canvas-wrap {
    border: 1px solid var(--border);
    border-radius: 14px;
    overflow: hidden;
    background: var(--paper);
    margin-top: 12px;
  }
  canvas {
    display: block;
    width: 100%;
    height: 800px;
    background: var(--paper);
  }

  /* Footer */
  .footer {
    margin-top: 12px;
    padding: 10px;
    color: var(--muted);
    font-size: 12px;
    text-align: center;
  }
  .kbd {
    font-family: ui-monospace, Menlo, Consolas, monospace;
    background: #fff;
    border: 1px solid var(--border);
    border-radius: 5px;
    padding: 2px 6px;
    font-size: 11px;
  }

  /* Caliper Measurement List */
  .caliper-list {
    background: var(--panel);
    border: 1px solid var(--border);
    border-radius: 12px;
    padding: 12px;
    margin-top: 12px;
  }
  .caliper-list-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 8px;
  }
  .caliper-list-title {
    font-size: 13px;
    font-weight: 600;
    color: var(--text);
  }
  .caliper-items {
    display: flex;
    flex-direction: column;
    gap: 6px;
  }
  .caliper-item {
    display: flex;
    align-items: center;
    gap: 10px;
    padding: 8px 10px;
    background: #fff;
    border: 1px solid var(--border);
    border-radius: 8px;
    font-size: 13px;
  }
  .caliper-item.active {
    border-color: var(--accent);
    background: #f0f7ff;
  }
  .caliper-item-color {
    width: 12px;
    height: 12px;
    border-radius: 3px;
  }
  .caliper-item-values {
    flex: 1;
    display: flex;
    gap: 16px;
  }
  .caliper-item-value {
    font-family: ui-monospace, Menlo, Consolas, monospace;
    font-weight: 600;
  }
  .caliper-item-label {
    color: var(--muted);
    font-size: 11px;
    margin-left: 2px;
  }
  .caliper-item-delete {
    background: none;
    border: none;
    color: var(--muted);
    cursor: pointer;
    padding: 4px;
    border-radius: 4px;
    font-size: 16px;
    line-height: 1;
  }
  .caliper-item-delete:hover {
    background: #fee;
    color: var(--warn);
  }
  .caliper-empty {
    color: var(--muted);
    font-size: 12px;
    text-align: center;
    padding: 12px;
  }
  .caliper-handle {
    cursor: grab;
  }
  .caliper-handle:active {
    cursor: grabbing;
  }

  /* Caliper floating status */
  .caliper-status {
    position: fixed;
    bottom: 20px;
    left: 50%;
    transform: translateX(-50%);
    background: rgba(0, 0, 0, 0.85);
    color: white;
    padding: 10px 20px;
    border-radius: 24px;
    font-size: 13px;
    font-weight: 500;
    display: none;
    align-items: center;
    gap: 10px;
    z-index: 1000;
    box-shadow: 0 4px 20px rgba(0,0,0,0.3);
    animation: slideUp 0.2s ease-out;
  }
  .caliper-status.active { display: flex; }
  .caliper-status .dot {
    width: 8px;
    height: 8px;
    background: #4caf50;
    border-radius: 50%;
    animation: pulse 1.5s infinite;
  }
  @keyframes slideUp {
    from { opacity: 0; transform: translateX(-50%) translateY(10px); }
    to { opacity: 1; transform: translateX(-50%) translateY(0); }
  }
  @keyframes pulse {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.4; }
  }

  /* Focus styles for accessibility */
  button:focus-visible, select:focus-visible, input:focus-visible, .tab:focus-visible {
    outline: 2px solid var(--accent);
    outline-offset: 2px;
  }

  /* Skip link for keyboard users */
  .skip-link {
    position: absolute;
    top: -40px;
    left: 0;
    background: var(--accent);
    color: white;
    padding: 8px 16px;
    z-index: 100;
    border-radius: 0 0 8px 0;
  }
  .skip-link:focus { top: 0; }

  /* Advanced Section */
  .advanced-toggle {
    display: flex;
    align-items: center;
    gap: 6px;
    color: var(--muted);
    font-size: 12px;
    cursor: pointer;
    padding: 6px 10px;
    border-radius: 8px;
    background: transparent;
    border: 1px solid transparent;
  }
  .advanced-toggle:hover { background: var(--btn); }
  .advanced-toggle:focus-visible {
    outline: 2px solid var(--accent);
    outline-offset: 2px;
  }
  .advanced-content {
    display: none;
    flex-wrap: wrap;
    gap: 12px;
    padding-top: 10px;
    border-top: 1px solid var(--border);
    margin-top: 10px;
  }
  .advanced-content.open { display: flex; }

  /* Print Styles */
  @media print {
    body { margin: 0; padding: 0; background: white; }
    .header, .tabs, .tab-panels, .mode-toggle, .reveal-btn, .footer { display: none !important; }
    .measurements.hidden { opacity: 1; max-height: none; overflow: visible; }
    .measurements.hidden::after { display: none; }
    .canvas-wrap { border: none; border-radius: 0; }
    canvas { height: auto; }
  }

  /* Mobile - Tablet */
  @media (max-width: 768px) {
    body { padding: 8px; }
    .header h1 { font-size: 1.3rem; }
    .tabs { flex-wrap: wrap; gap: 4px; }
    .tab-btn { padding: 8px 12px; font-size: 0.85rem; }
    .tab-panel { padding: 12px; }
    .tab-panel label { flex-direction: column; align-items: flex-start; gap: 4px; }
    .tab-panel input, .tab-panel select { width: 100%; max-width: none; }
    .measurements-grid { grid-template-columns: repeat(2, 1fr); gap: 8px; }
    canvas { height: 500px; min-height: 400px; }
    .mode-btn { padding: 8px 16px; font-size: 13px; }
    .canvas-wrap { border-radius: 8px; }
    .reveal-btn { padding: 10px 20px; font-size: 0.9rem; }
  }

  /* Mobile - Phone */
  @media (max-width: 480px) {
    body { padding: 4px; }
    .header { padding: 12px; margin-bottom: 12px; }
    .header h1 { font-size: 1.1rem; }
    .mode-toggle { margin-bottom: 8px; }
    .mode-btn { padding: 6px 12px; font-size: 12px; }
    .tabs { gap: 2px; padding: 0 8px; }
    .tab-btn { padding: 6px 10px; font-size: 0.8rem; flex: 1; text-align: center; }
    .tab-panel { padding: 8px; }
    .tab-panel label { font-size: 0.85rem; margin-bottom: 8px; }
    .measurements-grid { grid-template-columns: 1fr 1fr; gap: 6px; }
    .measurements-grid > div { padding: 6px 8px; font-size: 0.8rem; }
    canvas { height: 400px; min-height: 300px; }
    .reveal-btn { padding: 8px 16px; font-size: 0.85rem; width: 100%; }
    .footer { padding: 12px; font-size: 0.75rem; }
    .caliper-status { font-size: 0.8rem; padding: 6px 10px; }
  }

  /* Touch-friendly controls */
  @media (hover: none) and (pointer: coarse) {
    .tab-btn, .mode-btn, button, select, input {
      min-height: 44px;
      min-width: 44px;
    }
    .tab-panel label {
      padding: 4px 0;
    }
    .reveal-btn {
      min-height: 48px;
    }
  }

  /* Drag and drop overlay */
  body.drag-active::after {
    content: 'Drop ECG image here';
    position: fixed;
    inset: 0;
    background: rgba(0, 100, 200, 0.9);
    color: white;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 2rem;
    font-weight: bold;
    z-index: 10000;
    pointer-events: none;
    border: 4px dashed white;
    margin: 20px;
    border-radius: 20px;
  }

  /* ===== Generate from Image Modal ===== */
  .modal-overlay {
    position: fixed;
    inset: 0;
    background: rgba(0, 0, 0, 0.7);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 10001;
    opacity: 0;
    visibility: hidden;
    transition: opacity 0.2s, visibility 0.2s;
  }
  .modal-overlay.visible {
    opacity: 1;
    visibility: visible;
  }
  .modal-content {
    background: var(--bg);
    border-radius: 12px;
    padding: 24px;
    max-width: 600px;
    width: 90%;
    max-height: 90vh;
    overflow-y: auto;
    box-shadow: 0 20px 60px rgba(0,0,0,0.4);
  }
  .modal-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 16px;
    padding-bottom: 12px;
    border-bottom: 1px solid var(--grid);
  }
  .modal-header h2 {
    margin: 0;
    font-size: 1.25rem;
    color: var(--fg);
  }
  .modal-close {
    background: none;
    border: none;
    font-size: 1.5rem;
    cursor: pointer;
    color: var(--muted);
    padding: 4px 8px;
    border-radius: 4px;
  }
  .modal-close:hover {
    background: var(--grid);
    color: var(--fg);
  }
  .modal-preview {
    background: #111;
    border-radius: 8px;
    padding: 8px;
    margin-bottom: 16px;
    text-align: center;
  }
  .modal-preview img {
    max-width: 100%;
    max-height: 200px;
    border-radius: 4px;
  }
  .modal-preview-label {
    font-size: 11px;
    color: var(--muted);
    margin-top: 6px;
  }
  .modal-form {
    display: flex;
    flex-direction: column;
    gap: 16px;
  }
  .modal-form label {
    display: flex;
    flex-direction: column;
    gap: 6px;
    font-size: 13px;
    color: var(--fg);
  }
  .modal-form select,
  .modal-form input[type="range"] {
    width: 100%;
  }
  .modal-form select {
    padding: 8px;
    border-radius: 6px;
    border: 1px solid var(--grid);
    background: var(--bg);
    color: var(--fg);
    font-size: 14px;
  }
  .modal-range-row {
    display: flex;
    align-items: center;
    gap: 12px;
  }
  .modal-range-row input[type="range"] {
    flex: 1;
  }
  .modal-range-value {
    min-width: 60px;
    text-align: right;
    font-weight: bold;
    font-size: 14px;
  }
  .modal-hr-estimate {
    font-size: 11px;
    color: var(--muted);
    margin-top: 2px;
  }
  .modal-actions {
    display: flex;
    gap: 12px;
    margin-top: 8px;
  }
  .modal-actions button {
    flex: 1;
    padding: 12px;
    border-radius: 8px;
    font-size: 14px;
    font-weight: 600;
    cursor: pointer;
    border: none;
  }
  .modal-actions .btn-primary {
    background: var(--accent);
    color: white;
  }
  .modal-actions .btn-primary:hover {
    filter: brightness(1.1);
  }
  .modal-actions .btn-secondary {
    background: var(--grid);
    color: var(--fg);
  }
  .modal-actions .btn-secondary:hover {
    background: var(--muted);
  }
  .modal-tip {
    font-size: 11px;
    color: var(--muted);
    background: rgba(100,150,255,0.1);
    padding: 10px 12px;
    border-radius: 6px;
    margin-top: 8px;
  }
</style>
</head>
<body>

<!-- Skip link for keyboard navigation -->
<a href="#ecgCanvas" class="skip-link">Skip to ECG</a>

<!-- Header -->
<header class="header" role="banner">
  <div style="display:flex; align-items:center; gap:12px">
    <h1>EKGQuest Lab</h1>
    <span class="header-badge badge-synth" id="sourceBadge" role="status" aria-live="polite">SYNTHETIC</span>
  </div>

  <div class="mode-toggle" role="group" aria-label="Display mode">
    <button class="mode-btn active-quiz" id="quizModeBtn" onclick="setMode('quiz')" aria-pressed="true">Quiz Mode</button>
    <button class="mode-btn" id="teachModeBtn" onclick="setMode('teach')" aria-pressed="false">Teach Mode</button>
  </div>

  <button class="reveal-btn" id="revealBtn" onclick="reveal()" aria-label="Reveal diagnosis and measurements">Reveal Answers</button>

  <div class="header-info">
    <span id="caseInfo">No case loaded</span>
    <span id="statusMsg" class="status-msg" role="status" aria-live="polite"></span>
  </div>
</header>

<!-- Tabs -->
<div class="tabs">
  <button class="tab active" onclick="showTab('case')">Case</button>
  <button class="tab" onclick="showTab('view')">View</button>
  <button class="tab" onclick="showTab('tools')">Tools</button>
  <button class="tab" onclick="showTab('compare')">Compare</button>
  <button class="tab" onclick="showTab('export')">Export</button>
</div>

<!-- Tab Panels -->
<div class="tab-panels">
  <!-- Case Panel -->
  <div class="tab-panel active" id="panel-case">
    <label>Age (years)
      <input id="ageYears" type="number" min="0" max="100" step="0.1" value="45">
    </label>
    <label>Sex
      <select id="sex">
        <option value="">Any</option>
        <option value="male">Male</option>
        <option value="female">Female</option>
      </select>
    </label>
    <label>Diagnosis
      <select id="dx">
        <optgroup label="Normal">
          <option>Normal sinus</option>
          <option>Sinus bradycardia</option>
          <option>Sinus tachycardia</option>
        </optgroup>
        <optgroup label="Conduction">
          <option>RBBB</option>
          <option>LBBB</option>
          <option>LAFB</option>
          <option>1st degree AVB</option>
          <option>2nd degree AVB (Wenckebach)</option>
          <option>2nd degree AVB (Mobitz II)</option>
          <option>3rd degree AVB</option>
        </optgroup>
        <optgroup label="Pre-excitation">
          <option>WPW</option>
        </optgroup>
        <optgroup label="Hypertrophy">
          <option>LVH</option>
          <option>RVH</option>
        </optgroup>
        <optgroup label="Tachyarrhythmias">
          <option>SVT (narrow)</option>
          <option>Atrial flutter (2:1)</option>
          <option>Atrial fibrillation</option>
        </optgroup>
        <optgroup label="Ischemia">
          <option>STEMI (anterior)</option>
        </optgroup>
        <optgroup label="Repolarization">
          <option>Long QT</option>
          <option>Pericarditis</option>
          <option>Brugada (Type 1)</option>
        </optgroup>
        <optgroup label="Metabolic">
          <option>Hyperkalemia</option>
        </optgroup>
        <optgroup label="Ectopy">
          <option>PACs</option>
          <option>PVCs</option>
        </optgroup>
      </select>
    </label>
    <label>Seed
      <input id="seed" type="number" min="1" step="1" value="7">
    </label>
    <button class="primary" id="genBtn" onclick="generate()">Generate</button>
    <button id="randBtn" onclick="randomize()">Random</button>
    <div class="divider"></div>
    <label>Load JSON/CSV
      <input type="file" id="fileInput" accept=".json,.csv">
    </label>
    <div class="divider"></div>
    <div class="upload-section">
      <strong style="font-size:12px;color:var(--muted)">Import Real ECG</strong>
      <div class="import-hint" style="font-size:10px;color:#888;margin-bottom:4px">
        âŒ˜V paste â€¢ âŒ˜O open â€¢ Drag image anywhere â€¢ Drop URL
      </div>
      <button id="clipboardBtn" onclick="loadFromClipboard()" title="Copy any ECG image, then click this (âŒ˜V)">
        ðŸ“‹ Paste from Clipboard
      </button>
      <label>Upload PDF or Image
        <input type="file" id="imageInput" accept=".pdf,.png,.jpg,.jpeg,.webp">
      </label>
      <div id="calibrationControls" style="display:none">
        <label>Paper speed
          <select id="importSpeed" onchange="redraw()">
            <option value="25" selected>25 mm/s</option>
            <option value="50">50 mm/s</option>
          </select>
        </label>
        <label>Gain
          <select id="importGain" onchange="redraw()">
            <option value="10" selected>10 mm/mV</option>
            <option value="5">5 mm/mV</option>
            <option value="20">20 mm/mV</option>
          </select>
        </label>
        <button onclick="extractTraceFromImage()" class="primary" title="Auto-extract ECG trace from image">Extract Trace</button>
        <button id="calibrateBtn" onclick="startCalibration()">Calibrate (for calipers)</button>
        <button onclick="clearUploadedImage()">Clear</button>
        <div id="calibrationStatus" class="hint" style="display:none"></div>
      </div>
    </div>
  </div>

  <!-- View Panel -->
  <div class="tab-panel" id="panel-view">
    <label>Layout
      <select id="layout" onchange="redraw()">
        <option value="stacked" selected>Stacked (15 leads)</option>
        <option value="print12">12-lead print + rhythm</option>
      </select>
    </label>
    <label>Speed
      <select id="speed" onchange="redraw()">
        <option value="25" selected>25 mm/s</option>
        <option value="50">50 mm/s</option>
      </select>
    </label>
    <label>Gain
      <select id="gain" onchange="redraw()">
        <option value="5">5 mm/mV</option>
        <option value="10" selected>10 mm/mV</option>
        <option value="20">20 mm/mV</option>
      </select>
    </label>
    <label>Scale
      <select id="pxmm" onchange="redraw()">
        <option value="4" selected>Fit</option>
        <option value="6">Medium</option>
        <option value="8">Large</option>
      </select>
    </label>
    <div class="divider"></div>
    <button type="button" class="advanced-toggle" onclick="toggleAdvanced()" aria-expanded="false" aria-controls="advancedContent">
      <span id="advIcon" aria-hidden="true">+</span> Advanced
    </button>
    <div class="advanced-content" id="advancedContent">
      <label><input id="noise" type="checkbox" checked onchange="generate()"> Noise</label>
      <label><input id="filters" type="checkbox" checked onchange="generate()"> Diagnostic filter</label>
      <label><input id="fid" type="checkbox" checked onchange="redraw()"> Fiducials</label>
      <label><input id="snap" type="checkbox" checked> Snap calipers</label>
      <label><input id="median" type="checkbox" checked onchange="redraw()"> Median-beat</label>
    </div>
  </div>

  <!-- Tools Panel -->
  <div class="tab-panel" id="panel-tools">
    <button id="calBtn" class="primary" onclick="toggleCalipers()">Calipers: OFF</button>
    <label><input id="snapPeaks" type="checkbox" checked> Snap to R-peaks</label>
    <label><input id="snapGrid" type="checkbox"> Snap to grid</label>
    <button onclick="clearAllCalipers()">Clear All</button>
    <div class="divider"></div>
    <div class="caliper-instructions">
      <strong>How to measure:</strong>
      <ol style="margin:4px 0 0 16px;padding:0;font-size:12px;color:var(--muted)">
        <li>Click and drag across the waveform</li>
        <li>Release to create measurement</li>
        <li>Click measurement to select, drag handles to adjust</li>
      </ol>
    </div>
    <div class="divider"></div>
    <span class="hint">
      <span class="kbd">C</span> Toggle &nbsp;
      <span class="kbd">Shift</span> Lock H/V &nbsp;
      <span class="kbd">Del</span> Delete &nbsp;
      <span class="kbd">Esc</span> Cancel
    </span>
    <div class="divider"></div>
    <strong style="font-size:12px;color:var(--muted)">One-Click Import</strong>
    <p style="font-size:11px;color:var(--muted);margin:4px 0">Drag this to your bookmarks bar:</p>
    <a id="bookmarklet" href="javascript:(function(){var imgs=document.querySelectorAll('img');if(imgs.length===0){alert('No images found');return;}var largest=null,maxArea=0;imgs.forEach(function(img){var area=img.naturalWidth*img.naturalHeight;if(area>maxArea){maxArea=area;largest=img;}});if(largest&&maxArea>10000){window.open('http://localhost:8000/viewer/ekgquest_lab.html?img='+encodeURIComponent(largest.src),'_blank');}else{alert('No suitable ECG image found');}})();"
       style="display:inline-block;background:#1976d2;color:white;padding:6px 12px;border-radius:6px;text-decoration:none;font-size:12px;font-weight:600;cursor:move"
       onclick="event.preventDefault();alert('Drag this to your bookmarks bar, then click it on any page with an ECG image!')">
      ðŸ“‹ ECG â†’ EKGQuest
    </a>
    <p style="font-size:10px;color:var(--muted);margin:4px 0">Click on any page with an ECG image to send it here.</p>
  </div>

  <!-- Compare Panel -->
  <div class="tab-panel" id="panel-compare">
    <button id="storeRefBtn" class="primary" onclick="storeReference()">Store as Reference</button>
    <button id="clearRefBtn" onclick="clearReference()" disabled>Clear Reference</button>
    <div class="divider"></div>
    <label><input id="showOverlay" type="checkbox" onchange="redraw()" disabled> Show overlay</label>
    <label><input id="showDiff" type="checkbox" onchange="redraw()"> Highlight differences</label>
    <div class="divider"></div>
    <div id="refInfo" class="hint">No reference stored</div>
  </div>

  <!-- Export Panel -->
  <div class="tab-panel" id="panel-export">
    <button onclick="printWorksheet()">Print Worksheet</button>
    <button onclick="printAnswerKey()">Print Answer Key</button>
    <div class="divider"></div>
    <button onclick="exportPNG()">Export PNG</button>
    <button onclick="exportJSON()">Export JSON</button>
    <button onclick="exportCSV()">Export CSV</button>
  </div>
</div>

<!-- Measurements -->
<div class="measurements hidden" id="measurements">
  <div class="measurements-grid">
    <div class="metric"><div class="metric-label">Heart Rate</div><div class="metric-value" id="m_hr">â€”</div></div>
    <div class="metric"><div class="metric-label">PR Interval</div><div class="metric-value" id="m_pr">â€”</div></div>
    <div class="metric"><div class="metric-label">QRS Duration</div><div class="metric-value" id="m_qrs">â€”</div></div>
    <div class="metric"><div class="metric-label">QT Interval</div><div class="metric-value" id="m_qt">â€”</div></div>
    <div class="metric"><div class="metric-label">QTc (Bazett)</div><div class="metric-value" id="m_qtc">â€”</div></div>
    <div class="metric"><div class="metric-label">Axes (P/QRS/T)</div><div class="metric-value" id="m_axes">â€”</div></div>
    <div class="metric" id="diagnosisMetric"><div class="metric-label">Diagnosis</div><div class="metric-value" id="m_dx">â€”</div></div>
    <div class="metric"><div class="metric-label">Age/Sex</div><div class="metric-value" id="m_age">â€”</div></div>
  </div>
</div>

<!-- ECG Canvas -->
<div class="canvas-wrap" id="ecgCanvas" role="img" aria-label="Electrocardiogram display">
  <canvas id="c" tabindex="0" aria-label="ECG waveform - use calipers to measure intervals"></canvas>
</div>

<!-- Caliper Measurements List -->
<div class="caliper-list" id="caliperList" style="display:none">
  <div class="caliper-list-header">
    <span class="caliper-list-title">Caliper Measurements</span>
    <button onclick="clearAllCalipers()" style="font-size:12px;padding:4px 10px">Clear All</button>
  </div>
  <div class="caliper-items" id="caliperItems">
    <div class="caliper-empty">Click two points on the ECG to measure intervals</div>
  </div>
</div>

<!-- Caliper Status Indicator -->
<div class="caliper-status" id="caliperStatus">
  <span class="dot"></span>
  <span>Caliper Mode: Click and drag to measure</span>
</div>

<!-- Footer -->
<div class="footer">
  EKGQuest Lab â€” Educational ECG synthesis and teaching tool.
  Synthetic data for learning only; not for clinical use.
</div>

<script type="module">
import {
  ECG_SCHEMA_VERSION,
  clamp, lerp, medianOfSmallArray, medianWindow, mean,
  fmtMs, fmtBpm, fmtDeg,
  physicsChecks, detectRPeaks,
  buildMedianBeat, fiducialsFromMedian, buildFullFiducialsFromMedian,
  computeAxesFromMedian, computeGlobalMeasurements
} from "/viewer/js/ecg-core.js";

// Will be imported dynamically when synthesizer is used
let synthModule = null;

// ============================================================================
// STATE
// ============================================================================

let currentMode = 'quiz';  // 'quiz' or 'teach'
let ecgData = null;
let measurements = null;
let panOffset = 0;
let zoomLevel = 1;

// Advanced Caliper State
let calipersActive = false;
let caliperMeasurements = [];  // Array of completed measurements
let activeCaliperPoint = null; // First point of in-progress measurement
let selectedCaliperId = null;  // Currently selected measurement for editing
let draggingHandle = null;     // { measurementId, handle: 'p1' | 'p2' }
let shiftHeld = false;
let lastMousePos = null;

// Comparison mode state
let referenceECG = null;       // Stored reference ECG for comparison
let referenceMeta = null;      // Metadata about the reference (age, dx, etc.)

// Uploaded image state
let uploadedImage = null;      // HTMLImageElement of uploaded ECG
let uploadedImageName = null;  // Original filename
let imageMode = false;         // Are we displaying an uploaded image?
let imageCalibration = null;   // { pxPerMm, offsetX, offsetY, drawW, drawH } - actual calibration from image

// Calibration mode state
let calibrationMode = false;   // Are we in calibration mode?
let calibrationPoint1 = null;  // First calibration point

const CALIPER_COLORS = ['#1b6dff', '#e91e63', '#4caf50', '#ff9800', '#9c27b0', '#00bcd4'];
let nextCaliperColor = 0;

// ============================================================================
// DIGITIZATION SERVICE (Viterbi Backend)
// ============================================================================

const DIGITIZE_API_URL = 'http://localhost:5001/api/digitize';
const CALIBRATE_API_URL = 'http://localhost:5001/api/calibrate';
let digitizeBackendAvailable = false;

// Check if digitization backend is available
async function checkDigitizeBackend() {
  try {
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), 2000);

    const response = await fetch('http://localhost:5001/api/health', {
      method: 'GET',
      signal: controller.signal
    });

    clearTimeout(timeoutId);

    if (response.ok) {
      digitizeBackendAvailable = true;
      console.log('Enhanced digitization backend available (Viterbi algorithm)');
      return true;
    }
  } catch (e) {
    digitizeBackendAvailable = false;
    console.log('Digitization backend not available, using client-side extraction');
  }
  return false;
}

// Check backend on page load
checkDigitizeBackend();

/**
 * Detect grid spacing from an ECG image using autocorrelation.
 * Works with any grid color (red, green, blue, gray).
 */
function detectGridSpacing(img) {
  // Create canvas to analyze image
  const canvas = document.createElement('canvas');
  canvas.width = img.width;
  canvas.height = img.height;
  const ctx = canvas.getContext('2d');
  ctx.drawImage(img, 0, 0);
  const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
  const { data, width, height } = imageData;

  // Convert to grayscale and detect edges
  const gray = new Float32Array(width * height);
  for (let y = 0; y < height; y++) {
    for (let x = 0; x < width; x++) {
      const i = (y * width + x) * 4;
      gray[y * width + x] = (data[i] + data[i + 1] + data[i + 2]) / 3;
    }
  }

  // Compute vertical edge strength (for detecting vertical grid lines)
  const edgeStrength = new Float32Array(width);
  for (let x = 1; x < width - 1; x++) {
    let sum = 0;
    for (let y = 0; y < height; y++) {
      const idx = y * width + x;
      const diff = Math.abs(gray[idx + 1] - gray[idx - 1]);
      sum += diff;
    }
    edgeStrength[x] = sum;
  }

  // Normalize edge strength
  const maxEdge = Math.max(...edgeStrength);
  if (maxEdge < 1) return null;
  for (let i = 0; i < edgeStrength.length; i++) {
    edgeStrength[i] /= maxEdge;
  }

  // Autocorrelation to find periodicity
  const maxLag = Math.min(200, Math.floor(width / 4));
  const autocorr = new Float32Array(maxLag);

  const mean = edgeStrength.reduce((a, b) => a + b, 0) / edgeStrength.length;
  for (let lag = 0; lag < maxLag; lag++) {
    let sum = 0;
    let count = 0;
    for (let i = 0; i < edgeStrength.length - lag; i++) {
      sum += (edgeStrength[i] - mean) * (edgeStrength[i + lag] - mean);
      count++;
    }
    autocorr[lag] = sum / count;
  }

  // Normalize autocorrelation
  const ac0 = autocorr[0];
  if (ac0 < 1e-6) return null;
  for (let i = 0; i < autocorr.length; i++) {
    autocorr[i] /= ac0;
  }

  // Find first significant peak (skip lag 0)
  const minSpacing = 8;  // Minimum expected grid spacing in pixels
  let bestPeak = null;
  let bestHeight = 0.15;  // Minimum peak height threshold

  for (let i = minSpacing; i < autocorr.length - 1; i++) {
    if (autocorr[i] > autocorr[i - 1] &&
        autocorr[i] > autocorr[i + 1] &&
        autocorr[i] > bestHeight) {
      // Sub-pixel refinement via quadratic interpolation
      const y0 = autocorr[i - 1];
      const y1 = autocorr[i];
      const y2 = autocorr[i + 1];
      const denom = y0 - 2 * y1 + y2;
      let peakPos = i;
      if (Math.abs(denom) > 1e-10) {
        peakPos = i + 0.5 * (y0 - y2) / denom;
      }

      bestPeak = peakPos;
      bestHeight = autocorr[i];
      break;  // Take first significant peak
    }
  }

  if (bestPeak === null) return null;

  // Grid spacing = pixels per small box (1mm)
  // Confidence based on peak height
  const confidence = Math.min(1.0, bestHeight * 1.5);

  return {
    pxPerMm: bestPeak,
    confidence: confidence
  };
}

/**
 * Digitize ECG image using the Viterbi backend (enhanced mode).
 */
async function digitizeWithBackend(imageBlob, options = {}) {
  const {
    paperSpeed = 25,
    voltageScale = 10,
    leadHint = 'II',
    crop = null
  } = options;

  if (!imageBlob) {
    throw new Error('No image blob provided');
  }

  console.log('Sending image to backend:', imageBlob.size, 'bytes');

  const formData = new FormData();
  formData.append('image', imageBlob, 'ecg.png');
  formData.append('paper_speed', paperSpeed.toString());
  formData.append('voltage_scale', voltageScale.toString());
  formData.append('lead_hint', leadHint);
  if (crop) {
    formData.append('crop', JSON.stringify(crop));
  }

  const response = await fetch(DIGITIZE_API_URL, {
    method: 'POST',
    body: formData
  });

  const responseData = await response.json().catch(() => ({ error: 'Failed to parse response' }));

  if (!response.ok) {
    console.error('Digitization error:', responseData);
    throw new Error(responseData.error || `Server error: ${response.status}`);
  }

  console.log('Digitization result:', responseData);
  return responseData;
}

/**
 * Convert uploaded image to blob for sending to backend.
 */
function imageToBlob(img) {
  return new Promise((resolve, reject) => {
    try {
      const canvas = document.createElement('canvas');
      canvas.width = img.width || img.naturalWidth;
      canvas.height = img.height || img.naturalHeight;

      if (canvas.width === 0 || canvas.height === 0) {
        reject(new Error('Image has zero dimensions'));
        return;
      }

      const ctx = canvas.getContext('2d');
      ctx.drawImage(img, 0, 0);

      canvas.toBlob((blob) => {
        if (blob) {
          resolve(blob);
        } else {
          reject(new Error('Failed to create blob from image'));
        }
      }, 'image/png');
    } catch (err) {
      reject(err);
    }
  });
}

/**
 * Unified digitization function - tries backend first, falls back to client-side.
 */
async function digitizeECGImage(img, options = {}) {
  const {
    paperSpeed = 25,
    voltageScale = 10,
    forceBackend = false,
    forceClientSide = false
  } = options;

  // Try backend if available and not forcing client-side
  if (!forceClientSide && (forceBackend || digitizeBackendAvailable)) {
    try {
      showStatus('Digitizing with Viterbi algorithm...', 'info', 0);

      const blob = await imageToBlob(img);
      const result = await digitizeWithBackend(blob, {
        paperSpeed,
        voltageScale,
        leadHint: 'II'
      });

      if (result.success) {
        const leadData = result.leads['II'] || Object.values(result.leads)[0];

        showStatus(
          `Enhanced digitization: ${result.quality.score > 0.7 ? 'High' : 'Medium'} quality ` +
          `(${result.metadata.processing_time_ms}ms)`,
          result.quality.score > 0.7 ? 'success' : 'warning',
          4000
        );

        return {
          method: 'viterbi',
          fs: leadData.fs,
          duration_s: leadData.duration_s,
          leads_uV: buildAllLeadsFromLead2(leadData.samples_uV),
          quality: result.quality,
          calibration: result.calibration
        };
      }
    } catch (err) {
      console.warn('Backend digitization failed:', err.message);
      if (forceBackend) {
        throw err;  // Don't fall back if user explicitly requested backend
      }
      showStatus('Backend unavailable, using client-side extraction...', 'warning', 2000);
    }
  }

  // Fall back to client-side extraction
  showStatus('Extracting trace (client-side)...', 'info', 0);

  // Use existing extractTraceFromImage logic
  const canvas = document.createElement('canvas');
  canvas.width = img.width;
  canvas.height = img.height;
  const ctx = canvas.getContext('2d');
  ctx.drawImage(img, 0, 0);
  const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);

  const tracePixels = detectTracePixels(imageData);
  if (tracePixels.size < 100) {
    throw new Error('Could not detect trace. Try adjusting image contrast.');
  }

  const rawPoints = averagingWindowExtract(tracePixels, canvas.width, canvas.height);
  if (rawPoints.length < 50) {
    throw new Error('Not enough trace points detected.');
  }

  // Convert to physical units
  const pxPerMm = imageCalibration?.pxPerMm || estimatePxPerMm(canvas.width, canvas.height);
  const mmPerSec = paperSpeed;
  const mmPerMV = voltageScale;

  const pxPerSec = pxPerMm * mmPerSec;
  const pxPerMV = pxPerMm * mmPerMV;

  // Find baseline
  const yValues = rawPoints.map(p => p.y);
  yValues.sort((a, b) => a - b);
  const baselineY = yValues[Math.floor(yValues.length / 2)];

  // Convert points to time/voltage
  const timeVoltage = rawPoints.map(p => ({
    time: p.x / pxPerSec,
    voltage: (baselineY - p.y) / pxPerMV
  }));
  timeVoltage.sort((a, b) => a.time - b.time);

  // Resample to 500 Hz
  const fs = 500;
  const duration = timeVoltage[timeVoltage.length - 1].time;
  const numSamples = Math.round(duration * fs);
  const resampled = new Float32Array(numSamples);

  for (let i = 0; i < numSamples; i++) {
    const t = i / fs;
    let j = 0;
    while (j < timeVoltage.length - 1 && timeVoltage[j + 1].time < t) j++;

    if (j >= timeVoltage.length - 1) {
      resampled[i] = timeVoltage[timeVoltage.length - 1].voltage;
    } else {
      const t0 = timeVoltage[j].time, t1 = timeVoltage[j + 1].time;
      const v0 = timeVoltage[j].voltage, v1 = timeVoltage[j + 1].voltage;
      const alpha = (t - t0) / (t1 - t0 || 1);
      resampled[i] = v0 + alpha * (v1 - v0);
    }
  }

  // Convert to ÂµV
  const lead_uV = Array.from(resampled).map(v => v * 1000);

  showStatus(`Client-side extraction: ${rawPoints.length} points â†’ ${duration.toFixed(1)}s`, 'success');

  return {
    method: 'centroid',
    fs: fs,
    duration_s: duration,
    leads_uV: buildAllLeadsFromLead2(lead_uV),
    quality: { score: 0.6, issues: ['Client-side extraction - consider using backend for better accuracy'] }
  };
}

/**
 * Build all 12 leads from Lead II data (approximate derivation).
 */
function buildAllLeadsFromLead2(lead2_uV) {
  const leads_uV = { 'II': lead2_uV };

  // Approximate other leads from Lead II
  leads_uV['I'] = lead2_uV.map(v => v * 0.6);
  leads_uV['III'] = lead2_uV.map((v, i) => leads_uV['II'][i] - leads_uV['I'][i]);
  leads_uV['aVR'] = lead2_uV.map((v, i) => -(leads_uV['I'][i] + leads_uV['II'][i]) / 2);
  leads_uV['aVL'] = lead2_uV.map((v, i) => leads_uV['I'][i] - leads_uV['II'][i] / 2);
  leads_uV['aVF'] = lead2_uV.map((v, i) => leads_uV['II'][i] - leads_uV['I'][i] / 2);
  leads_uV['V1'] = lead2_uV.map(v => v * -0.3);
  leads_uV['V2'] = lead2_uV.map(v => v * -0.1);
  leads_uV['V3'] = lead2_uV.map(v => v * 0.2);
  leads_uV['V4'] = lead2_uV.map(v => v * 0.5);
  leads_uV['V5'] = lead2_uV.map(v => v * 0.7);
  leads_uV['V6'] = lead2_uV.map(v => v * 0.8);

  return leads_uV;
}

// ============================================================================
// STATUS MESSAGES
// ============================================================================

let statusTimeout = null;
function showStatus(message, type = 'info', duration = 4000) {
  const el = document.getElementById('statusMsg');
  if (!el) return;

  // Clear previous timeout
  if (statusTimeout) clearTimeout(statusTimeout);

  el.textContent = message;
  el.className = `status-msg visible ${type}`;

  if (duration > 0) {
    statusTimeout = setTimeout(() => {
      el.className = 'status-msg';
    }, duration);
  }
}

function clearStatus() {
  const el = document.getElementById('statusMsg');
  if (el) el.className = 'status-msg';
}

// ============================================================================
// MODE MANAGEMENT
// ============================================================================

window.setMode = function(mode) {
  currentMode = mode;

  // Update buttons and aria-pressed state
  const quizBtn = document.getElementById('quizModeBtn');
  const teachBtn = document.getElementById('teachModeBtn');
  quizBtn.className = mode === 'quiz' ? 'mode-btn active-quiz' : 'mode-btn';
  teachBtn.className = mode === 'teach' ? 'mode-btn active-teach' : 'mode-btn';
  quizBtn.setAttribute('aria-pressed', mode === 'quiz');
  teachBtn.setAttribute('aria-pressed', mode === 'teach');

  // Update reveal button visibility
  document.getElementById('revealBtn').className = mode === 'quiz' ? 'reveal-btn visible' : 'reveal-btn';

  // Update measurements visibility
  const measPanel = document.getElementById('measurements');
  measPanel.className = mode === 'quiz' ? 'measurements hidden' : 'measurements';

  // Update fiducials visibility on canvas
  if (mode === 'teach') {
    document.getElementById('fid').checked = true;
  }
  redraw();
};

window.reveal = function() {
  setMode('teach');
};

// ============================================================================
// TAB MANAGEMENT
// ============================================================================

window.showTab = function(tabId) {
  const tabIds = ['case', 'view', 'tools', 'compare', 'export'];
  document.querySelectorAll('.tab').forEach((t, i) => {
    t.className = tabIds[i] === tabId ? 'tab active' : 'tab';
  });
  document.querySelectorAll('.tab-panel').forEach(p => p.className = 'tab-panel');
  document.getElementById('panel-' + tabId).className = 'tab-panel active';
};

window.toggleAdvanced = function() {
  const content = document.getElementById('advancedContent');
  const icon = document.getElementById('advIcon');
  const btn = document.querySelector('.advanced-toggle');
  const isOpen = content.classList.contains('open');

  if (isOpen) {
    content.classList.remove('open');
    icon.textContent = '+';
    btn?.setAttribute('aria-expanded', 'false');
  } else {
    content.classList.add('open');
    icon.textContent = 'âˆ’';
    btn?.setAttribute('aria-expanded', 'true');
  }
};

// ============================================================================
// COMPARISON MODE
// ============================================================================

window.storeReference = function() {
  if (!ecgData) {
    showStatus('No ECG loaded to store as reference', 'warning');
    return;
  }

  // Deep copy the current ECG data
  referenceECG = JSON.parse(JSON.stringify(ecgData));

  // Store metadata for display
  const age = document.getElementById('ageYears').value;
  const dx = document.getElementById('dx').value;
  const seed = document.getElementById('seed').value;
  referenceMeta = { age, dx, seed };

  // Update UI
  document.getElementById('clearRefBtn').disabled = false;
  document.getElementById('showOverlay').disabled = false;
  document.getElementById('showOverlay').checked = true;
  document.getElementById('refInfo').innerHTML =
    `<strong>Reference:</strong> ${dx}<br>Age: ${age}y, Seed: ${seed}`;

  showStatus('Reference ECG stored', 'success', 2000);
  redraw();
};

window.clearReference = function() {
  referenceECG = null;
  referenceMeta = null;

  // Update UI
  document.getElementById('clearRefBtn').disabled = true;
  document.getElementById('showOverlay').disabled = true;
  document.getElementById('showOverlay').checked = false;
  document.getElementById('refInfo').textContent = 'No reference stored';

  showStatus('Reference cleared', 'info', 2000);
  redraw();
};

// ============================================================================
// SYNTHESIS
// ============================================================================

async function ensureSynth() {
  if (!synthModule) {
    synthModule = await import("/viewer/js/ecg-synth-modules.js");
  }
  return synthModule;
}

window.generate = async function() {
  const synth = await ensureSynth();

  const age = parseFloat(document.getElementById('ageYears').value) || 45;
  const sex = document.getElementById('sex').value || null;
  const dx = document.getElementById('dx').value;
  const seed = parseInt(document.getElementById('seed').value) || 7;
  const noiseEnabled = document.getElementById('noise').checked;
  const filtersEnabled = document.getElementById('filters').checked;

  // Use the unified synthesizer which handles all the complexity
  ecgData = synth.synthECGModular(age, dx, seed, {
    sex: sex || null,
    enableNoise: noiseEnabled,
    enableFilters: filtersEnabled,
    artifactParams: noiseEnabled ? synth.ARTIFACT_PRESETS.typical : synth.ARTIFACT_PRESETS.none,
    deviceParams: filtersEnabled ? synth.DEVICE_PRESETS.diagnostic : synth.DEVICE_PRESETS.raw
  });

  updateAfterLoad();
  showStatus('ECG generated', 'success', 2000);
};

window.randomize = function() {
  document.getElementById('seed').value = Math.floor(Math.random() * 99999) + 1;
  generate();
};

// ============================================================================
// FILE LOADING
// ============================================================================

document.getElementById('fileInput').addEventListener('change', async (e) => {
  const file = e.target.files[0];
  if (!file) return;

  try {
    const text = await file.text();

    // Check if this is a CSV file (from WebPlotDigitizer or similar)
    if (file.name.toLowerCase().endsWith('.csv')) {
      const csvData = parseCSVtoECG(text, file.name);
      if (csvData) {
        ecgData = csvData;
        imageMode = false;
        uploadedImage = null;
        document.getElementById('calibrationControls').style.display = 'none';
        updateAfterLoad();
        const leadCount = Object.keys(csvData.leads_uV).length;
        showStatus(`CSV imported: ${leadCount} lead(s) digitized`, 'success');
        return;
      } else {
        showStatus('Could not parse CSV. See console for format help.', 'error');
        console.log(`
CSV Import Format Help:
-----------------------
WebPlotDigitizer format (time, voltage):
  X,Y
  0,0.1
  0.004,0.15
  ...

Multi-lead format (time, lead1, lead2, ...):
  time,I,II,III,V1,V2,V3,V4,V5,V6
  0,0.1,0.2,0.1,0.05,...
  0.002,0.12,0.22,...

Units: Time in seconds, Voltage in mV
        `);
        return;
      }
    }

    const data = JSON.parse(text);

    // Check if this is a teaching case (uploaded image with measurements)
    if (data.type === 'teaching_case' && data.source?.imageData) {
      // Load the embedded image
      const img = new Image();
      img.src = data.source.imageData;
      await new Promise((resolve, reject) => {
        img.onload = resolve;
        img.onerror = () => reject(new Error('Failed to load embedded image'));
      });

      uploadedImage = img;
      uploadedImageName = data.source.filename || 'teaching-case.png';
      imageMode = true;
      ecgData = null;

      // Restore calibration settings
      if (data.calibration) {
        document.getElementById('importSpeed').value = data.calibration.paperSpeed_mm_s || 25;
        document.getElementById('importGain').value = data.calibration.gain_mm_mV || 10;
        if (data.calibration.scale_pxmm) {
          document.getElementById('pxmm').value = data.calibration.scale_pxmm;
        }
      }

      // Restore caliper measurements
      if (data.measurements) {
        caliperMeasurements = data.measurements.map(m => ({
          id: m.id || 'cal_' + Date.now() + Math.random(),
          p1: m.p1,
          p2: m.p2,
          color: m.color || CALIPER_COLORS[0]
        }));
        updateCaliperList();
      }

      document.getElementById('calibrationControls').style.display = 'flex';
      document.getElementById('caseInfo').textContent = `Teaching case: ${uploadedImageName}`;
      document.getElementById('measurements').classList.add('hidden');

      showStatus(`Teaching case loaded with ${caliperMeasurements.length} measurements`, 'success');
      redraw();
    } else {
      // Regular ECG JSON
      ecgData = data;
      imageMode = false;
      uploadedImage = null;
      document.getElementById('calibrationControls').style.display = 'none';
      updateAfterLoad();
      showStatus('File loaded successfully', 'success');
    }
  } catch (err) {
    showStatus('Failed to load file: ' + err.message, 'error', 6000);
  }
});

// Image/PDF upload handler
document.getElementById('imageInput').addEventListener('change', async (e) => {
  const file = e.target.files[0];
  if (!file) return;

  try {
    showStatus('Loading image...', 'info', 0);

    if (file.type === 'application/pdf') {
      // Load PDF.js dynamically
      if (!window.pdfjsLib) {
        const script = document.createElement('script');
        script.src = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js';
        document.head.appendChild(script);
        await new Promise((resolve, reject) => {
          script.onload = resolve;
          script.onerror = () => reject(new Error('Failed to load PDF.js'));
        });
        window.pdfjsLib.GlobalWorkerOptions.workerSrc =
          'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
      }

      // Load and render PDF
      const arrayBuffer = await file.arrayBuffer();
      const pdf = await window.pdfjsLib.getDocument({ data: arrayBuffer }).promise;
      const page = await pdf.getPage(1);

      // Render at high resolution for quality
      const scale = 2.0;
      const viewport = page.getViewport({ scale });

      const tempCanvas = document.createElement('canvas');
      tempCanvas.width = viewport.width;
      tempCanvas.height = viewport.height;
      const tempCtx = tempCanvas.getContext('2d');

      await page.render({ canvasContext: tempCtx, viewport }).promise;

      // Convert to image
      const img = new Image();
      img.src = tempCanvas.toDataURL('image/png');
      await new Promise(resolve => img.onload = resolve);

      uploadedImage = img;
    } else {
      // Load regular image
      const img = new Image();
      img.src = URL.createObjectURL(file);
      await new Promise((resolve, reject) => {
        img.onload = resolve;
        img.onerror = () => reject(new Error('Failed to load image'));
      });
      uploadedImage = img;
    }

    uploadedImageName = file.name;
    imageMode = true;
    ecgData = null;  // Clear synthetic data
    measurements = null;

    // Show calibration controls
    document.getElementById('calibrationControls').style.display = 'flex';

    // Update case info
    document.getElementById('caseInfo').textContent = `Imported: ${file.name}`;
    document.getElementById('measurements').classList.add('hidden');

    // Attempt auto-calibration
    const detected = detectGridSpacing(uploadedImage);
    const statusEl = document.getElementById('calibrationStatus');

    if (detected && detected.confidence > 0.6) {
      imageCalibration = {
        pxPerMm: detected.pxPerMm,
        calibrated: true,
        method: 'auto'
      };
      statusEl.style.display = 'block';
      statusEl.innerHTML = `<strong>Auto-calibrated:</strong> ${detected.pxPerMm.toFixed(1)} px/mm`;
      statusEl.style.color = '#2e7d32';
      document.getElementById('calibrateBtn').textContent = 'Recalibrate';
      showStatus('Image loaded & auto-calibrated â€” ready to measure!', 'success');
    } else {
      imageCalibration = null;
      statusEl.style.display = 'block';
      statusEl.innerHTML = 'Click <strong>Calibrate Grid</strong> for accurate measurements';
      statusEl.style.color = '#ff9800';
      showStatus('Image loaded â€” calibrate for accurate measurements', 'info');
    }

    redraw();

  } catch (err) {
    showStatus('Failed to load image: ' + err.message, 'error', 6000);
    console.error(err);
  }
});

window.clearUploadedImage = function() {
  // Securely clear image data
  if (uploadedImage) {
    // Revoke any blob URLs
    if (uploadedImage.src && uploadedImage.src.startsWith('blob:')) {
      URL.revokeObjectURL(uploadedImage.src);
    }
    // Clear image source
    uploadedImage.src = '';
  }

  uploadedImage = null;
  uploadedImageName = null;
  imageMode = false;
  imageCalibration = null;
  calibrationMode = false;
  calibrationPoint1 = null;
  document.getElementById('calibrationControls').style.display = 'none';
  document.getElementById('imageInput').value = '';
  document.getElementById('caseInfo').textContent = 'No case loaded';
  clearAllCalipers();
  redraw();
  showStatus('Image cleared and purged from memory', 'info', 2000);
};

// Load ECG from clipboard (direct paste or clipboard watcher)
window.loadFromClipboard = async function() {
  try {
    // First try native Clipboard API (modern browsers)
    if (navigator.clipboard && navigator.clipboard.read) {
      showStatus('Reading clipboard...', 'info', 0);
      const items = await navigator.clipboard.read();

      for (const item of items) {
        // Check for image
        const imageTypes = item.types.filter(t => t.startsWith('image/'));
        if (imageTypes.length > 0) {
          const blob = await item.getType(imageTypes[0]);
          const img = new Image();
          img.onload = function() {
            processImportedImage(img, 'clipboard-paste.png');
          };
          img.src = URL.createObjectURL(blob);
          return;
        }
      }
      showStatus('No image found in clipboard. Copy an ECG image first (Cmd+C)', 'warning');
    }

    // Fallback: try clipboard watcher API
    try {
      const response = await fetch('http://localhost:8001/latest-ecg');
      if (response.ok) {
        const data = await response.json();
        if (data && data.leads_uV) {
          ecgData = data;
          imageMode = false;
          uploadedImage = null;
          document.getElementById('calibrationControls').style.display = 'none';
          updateAfterLoad();
          showStatus('Loaded from Clipboard Watcher', 'success');
          return;
        }
      }
    } catch (e) {
      // Clipboard watcher not running, that's fine
    }

    showStatus('Copy an ECG image first (Cmd+C), then click this button', 'info');

  } catch (err) {
    console.error('Clipboard error:', err);
    showStatus('Clipboard access denied. Try: drag image directly onto canvas', 'warning');
  }
};

// Also support Cmd+V anywhere to paste
document.addEventListener('paste', async (e) => {
  const items = e.clipboardData?.items;
  if (!items) return;

  for (const item of items) {
    if (item.type.startsWith('image/')) {
      e.preventDefault();
      const blob = item.getAsFile();
      const img = new Image();
      img.onload = function() {
        processImportedImage(img, 'pasted-image.png');
      };
      img.src = URL.createObjectURL(blob);
      return;
    }
  }
});

// Keyboard shortcuts for frictionless import
document.addEventListener('keydown', (e) => {
  // Cmd+O or Ctrl+O: Open file dialog
  if ((e.metaKey || e.ctrlKey) && e.key === 'o') {
    e.preventDefault();
    document.getElementById('imageInput').click();
    return;
  }

  // Cmd+Shift+V: Force paste from clipboard (even if focused elsewhere)
  if ((e.metaKey || e.ctrlKey) && e.shiftKey && e.key === 'v') {
    e.preventDefault();
    loadFromClipboard();
    return;
  }

  // Escape: Cancel current import/calibration
  if (e.key === 'Escape' && (calibrationMode || imageMode)) {
    e.preventDefault();
    if (calibrationMode) {
      window.cancelCalibration();
    } else if (imageMode) {
      // Reset to synthetic mode
      imageMode = false;
      uploadedImage = null;
      document.getElementById('calibrationControls').style.display = 'none';
      generate();
    }
    return;
  }
});

// Drag and drop from anywhere (including directly from web pages)
const dropZone = document.body;
let dragCounter = 0;

dropZone.addEventListener('dragenter', (e) => {
  e.preventDefault();
  dragCounter++;
  document.body.classList.add('drag-active');
});

dropZone.addEventListener('dragleave', (e) => {
  e.preventDefault();
  dragCounter--;
  if (dragCounter === 0) {
    document.body.classList.remove('drag-active');
  }
});

dropZone.addEventListener('dragover', (e) => {
  e.preventDefault();
  e.dataTransfer.dropEffect = 'copy';
});

dropZone.addEventListener('drop', async (e) => {
  e.preventDefault();
  dragCounter = 0;
  document.body.classList.remove('drag-active');

  // Check for files first
  if (e.dataTransfer.files.length > 0) {
    const file = e.dataTransfer.files[0];
    if (file.type.startsWith('image/')) {
      loadDroppedImage(file);
      return;
    }
  }

  // Check for image URL (dragged from webpage)
  const html = e.dataTransfer.getData('text/html');
  const text = e.dataTransfer.getData('text/plain');

  // Try to extract image URL from HTML
  if (html) {
    const match = html.match(/<img[^>]+src=["']([^"']+)["']/i);
    if (match) {
      loadImageFromURL(match[1]);
      return;
    }
  }

  // Try plain text as URL
  if (text && (text.startsWith('http') || text.startsWith('data:image'))) {
    loadImageFromURL(text);
    return;
  }

  showStatus('Drop an ECG image or image URL', 'info');
});

function loadDroppedImage(file) {
  const img = new Image();
  img.onload = function() {
    processImportedImage(img, file.name);
  };
  img.src = URL.createObjectURL(file);
}

// Sanitize image: strip all EXIF/metadata, normalize size, enhance if needed
function sanitizeImage(img, callback) {
  // Create canvas to strip all metadata (EXIF, GPS, device info, etc.)
  const canvas = document.createElement('canvas');
  const ctx = canvas.getContext('2d');

  // Normalize size: too large images slow processing, too small lose detail
  const MAX_WIDTH = 4000;
  const MAX_HEIGHT = 3000;
  const MIN_WIDTH = 400;

  let width = img.width;
  let height = img.height;

  // Scale down if too large
  if (width > MAX_WIDTH || height > MAX_HEIGHT) {
    const scale = Math.min(MAX_WIDTH / width, MAX_HEIGHT / height);
    width = Math.round(width * scale);
    height = Math.round(height * scale);
  }

  // Warn if too small
  if (width < MIN_WIDTH) {
    console.warn('Image may be too small for accurate digitization');
  }

  canvas.width = width;
  canvas.height = height;

  // Draw image to canvas - this strips all metadata
  ctx.drawImage(img, 0, 0, width, height);

  // Check if image needs contrast enhancement
  const imageData = ctx.getImageData(0, 0, width, height);
  const data = imageData.data;

  // Calculate contrast (difference between dark and light areas)
  let minBright = 255, maxBright = 0;
  for (let i = 0; i < data.length; i += 16) { // Sample every 4th pixel
    const brightness = (data[i] + data[i+1] + data[i+2]) / 3;
    if (brightness < minBright) minBright = brightness;
    if (brightness > maxBright) maxBright = brightness;
  }

  const contrast = maxBright - minBright;

  // Enhance contrast if image is faint (low contrast)
  if (contrast < 100) {
    const scale = 200 / Math.max(contrast, 1);
    const offset = -minBright * scale;
    for (let i = 0; i < data.length; i += 4) {
      data[i] = Math.min(255, Math.max(0, data[i] * scale + offset));
      data[i+1] = Math.min(255, Math.max(0, data[i+1] * scale + offset));
      data[i+2] = Math.min(255, Math.max(0, data[i+2] * scale + offset));
    }
    ctx.putImageData(imageData, 0, 0);
  }

  // Revoke original object URL if it exists (free memory, remove reference)
  if (img.src && img.src.startsWith('blob:')) {
    URL.revokeObjectURL(img.src);
  }

  // Create new clean image from canvas pixels only
  canvas.toBlob((blob) => {
    const cleanImg = new Image();
    cleanImg.onload = function() {
      // Revoke the temporary blob URL after loading
      URL.revokeObjectURL(cleanImg.src);
      callback(cleanImg);
    };
    cleanImg.src = URL.createObjectURL(blob);
  }, 'image/png'); // Always output as PNG (no EXIF support)
}

// Sanitize filename: remove path, timestamps, device identifiers
function sanitizeFilename(name) {
  if (!name) return 'ecg_import.png';

  // Remove path components
  let clean = name.split(/[/\\]/).pop();

  // Remove common identifying patterns
  clean = clean
    .replace(/IMG_\d+/gi, 'ecg')           // iPhone IMG_1234
    .replace(/DSC_?\d+/gi, 'ecg')          // Camera DSC_1234
    .replace(/\d{4}-\d{2}-\d{2}/g, '')     // Dates 2024-01-15
    .replace(/\d{8}_\d{6}/g, '')           // Timestamps 20240115_143022
    .replace(/screenshot/gi, 'ecg')         // Screenshots
    .replace(/photo/gi, 'ecg')              // Photos
    .replace(/_+/g, '_')                    // Multiple underscores
    .replace(/^_|_$/g, '')                  // Leading/trailing underscores
    .replace(/\s+/g, '_');                  // Spaces to underscores

  // Ensure it has a valid extension
  if (!clean.match(/\.(png|jpg|jpeg)$/i)) {
    clean = clean.replace(/\.[^.]*$/, '') + '.png';
  }

  return clean || 'ecg_import.png';
}

// Process imported image - show modal for generating matching synthetic ECG
function processImportedImage(img, name) {
  // Sanitize the image (strip EXIF metadata for privacy)
  sanitizeImage(img, (cleanImg) => {
    uploadedImage = cleanImg;
    uploadedImageName = sanitizeFilename(name);

    // Clear reference to original
    img.src = '';
    img = null;

    // Show the generate modal with the image preview
    openGenerateModal(cleanImg);
  });
}

// ============================================================================
// GENERATE FROM IMAGE MODAL
// ============================================================================

let modalImageRef = null;

// Age to expected HR mapping (simplified from PEDIATRIC_PRIORS)
function getExpectedHR(age) {
  if (age < 1) return 140;
  if (age < 3) return 115;
  if (age < 6) return 100;
  if (age < 12) return 85;
  if (age < 18) return 75;
  return 70;
}

window.openGenerateModal = function(img) {
  modalImageRef = img;

  // Set preview image
  const previewImg = document.getElementById('modalPreviewImg');
  previewImg.src = img.src;

  // Reset form to defaults
  document.getElementById('modalDx').value = 'Normal sinus';
  document.getElementById('modalAge').value = 45;
  updateModalAgeDisplay();

  // Show modal
  document.getElementById('generateModal').classList.add('visible');
};

window.closeGenerateModal = function(event) {
  // If called from overlay click, only close if clicking the overlay itself
  if (event && event.target !== event.currentTarget) return;

  document.getElementById('generateModal').classList.remove('visible');
  modalImageRef = null;
};

window.updateModalAgeDisplay = function() {
  const age = parseInt(document.getElementById('modalAge').value);
  document.getElementById('modalAgeValue').textContent = age + ' yrs';

  const hr = getExpectedHR(age);
  document.getElementById('modalHREstimate').textContent = `Expected HR: ~${hr} bpm`;
};

window.generateFromModal = async function() {
  const age = parseInt(document.getElementById('modalAge').value);
  const dx = document.getElementById('modalDx').value;
  const seed = Math.floor(Math.random() * 99999) + 1;

  // Close modal
  closeGenerateModal();

  // Clear image mode state
  uploadedImage = null;
  imageMode = false;
  document.getElementById('calibrationControls').style.display = 'none';

  // Update main form to match modal selections
  document.getElementById('ageYears').value = age;
  document.getElementById('dx').value = dx;
  document.getElementById('seed').value = seed;

  // Generate the ECG
  showStatus('Generating matching ECG...', 'info', 0);

  const synth = await ensureSynth();
  const noiseEnabled = document.getElementById('noise').checked;
  const filtersEnabled = document.getElementById('filters').checked;

  ecgData = synth.synthECGModular(age, dx, seed, {
    sex: null,
    enableNoise: noiseEnabled,
    enableFilters: filtersEnabled,
    artifactParams: noiseEnabled ? synth.ARTIFACT_PRESETS.typical : synth.ARTIFACT_PRESETS.none,
    deviceParams: filtersEnabled ? synth.DEVICE_PRESETS.diagnostic : synth.DEVICE_PRESETS.raw
  });

  // Mark as inspired by uploaded image
  ecgData.targets.source = 'generated_from_image';

  updateAfterLoad();
  showStatus(`Generated ${dx} ECG (age ${age}) - perfect signal fidelity for measurements!`, 'success', 5000);
};

window.digitizeFromModal = async function() {
  if (!modalImageRef) {
    showStatus('No image to digitize', 'error');
    return;
  }

  // Save reference before closing modal (which clears modalImageRef)
  const imageToDigitize = modalImageRef;

  console.log('Digitizing image:', imageToDigitize.width, 'x', imageToDigitize.height);

  const dx = document.getElementById('modalDx').value;
  const age = parseInt(document.getElementById('modalAge').value);

  // Close modal (this sets modalImageRef = null)
  closeGenerateModal();

  try {
    // Check backend availability first
    const backendAvailable = await checkDigitizeBackend();
    console.log('Backend available:', backendAvailable);

    if (!backendAvailable) {
      showStatus('Digitization service not running. Using client-side extraction...', 'warning', 3000);
    }

    // Digitize the image
    const result = await digitizeECGImage(imageToDigitize, {
      paperSpeed: 25,
      voltageScale: 10
    });

    console.log('Digitization result:', result);

    // Build ECG data structure
    ecgData = {
      fs: result.fs,
      duration_s: result.duration_s,
      leads_uV: result.leads_uV,
      targets: {
        synthetic: false,
        digitized: true,
        source: uploadedImageName || 'uploaded_image',
        digitization_method: result.method,
        dx: dx,
        ageY: age
      },
      integrity: {
        digitization_quality: result.quality?.score || 0.5,
        digitization_issues: result.quality?.issues || []
      }
    };

    // Clear image state
    uploadedImage = null;
    imageMode = false;
    document.getElementById('calibrationControls').style.display = 'none';

    // Update UI
    updateAfterLoad();

    // Update source badge
    const badge = document.getElementById('sourceBadge');
    badge.textContent = 'DIGITIZED';
    badge.className = 'header-badge badge-import';

    const qualityText = result.quality?.score > 0.7 ? 'High' : result.quality?.score > 0.5 ? 'Medium' : 'Low';
    showStatus(
      `Digitized ECG: ${qualityText} quality (${result.method === 'viterbi' ? 'Viterbi' : 'Client-side'})`,
      result.quality?.score > 0.5 ? 'success' : 'warning',
      5000
    );

  } catch (err) {
    console.error('Digitization failed:', err);
    showStatus('Digitization failed: ' + err.message, 'error');
  }
};

// Fill in missing leads from available leads
function fillMissingLeads(leads_uV) {
  // Standard 12 leads + pediatric leads (V3R, V4R, V7, V8, V9)
  const STANDARD_LEADS = ['I', 'II', 'III', 'aVR', 'aVL', 'aVF', 'V1', 'V2', 'V3', 'V4', 'V5', 'V6'];
  const PEDIATRIC_LEADS = ['V3R', 'V4R', 'V7', 'V8', 'V9'];
  const filled = { ...leads_uV };
  const sampleCount = Object.values(leads_uV)[0]?.length || 5000;

  // Check if this is a pediatric ECG (has any right-sided or posterior leads)
  const hasPediatricLeads = PEDIATRIC_LEADS.some(lead => lead in filled);

  // If we have Lead II, use it as the basis
  const baseLead = filled['II'] || filled['I'] || Object.values(filled)[0];

  if (!baseLead) {
    // No leads at all, create zeros
    for (const lead of LEAD_NAMES) {
      filled[lead] = new Array(sampleCount).fill(0);
    }
    return filled;
  }

  // Fill limb leads using Einthoven relationships if possible
  const hasI = 'I' in filled;
  const hasII = 'II' in filled;
  const hasIII = 'III' in filled;

  if (!hasI && hasII) {
    // Estimate Lead I from Lead II (assume III ~ 0.4 * II)
    filled['I'] = baseLead.map(v => v * 0.6);
  }
  if (!hasII && hasI) {
    filled['II'] = filled['I'].map(v => v * 1.2);
  }
  if (!hasIII && hasI && hasII) {
    filled['III'] = filled['I'].map((v, i) => filled['II'][i] - v);
  }

  // Fill augmented leads
  if (!('aVR' in filled) && filled['I'] && filled['II']) {
    filled['aVR'] = filled['I'].map((v, i) => -(v + filled['II'][i]) / 2);
  }
  if (!('aVL' in filled) && filled['I'] && filled['II']) {
    filled['aVL'] = filled['I'].map((v, i) => v - filled['II'][i] / 2);
  }
  if (!('aVF' in filled) && filled['I'] && filled['II']) {
    filled['aVF'] = filled['II'].map((v, i) => v - filled['I'][i] / 2);
  }

  // Fill precordial leads with approximations if missing
  const precordialBase = filled['II'] || filled['I'] || baseLead;
  const precordialScales = { 'V1': -0.3, 'V2': -0.1, 'V3': 0.2, 'V4': 0.5, 'V5': 0.7, 'V6': 0.8 };

  for (const [lead, scale] of Object.entries(precordialScales)) {
    if (!(lead in filled)) {
      filled[lead] = precordialBase.map(v => v * scale);
    }
  }

  // Fill pediatric leads (right-sided V3R/V4R are roughly inverted V3/V4)
  // V7/V8/V9 are posterior leads, approximate from V6
  if (hasPediatricLeads) {
    if (!('V3R' in filled) && filled['V3']) {
      filled['V3R'] = filled['V3'].map(v => -v * 0.7); // Right-sided, inverted
    }
    if (!('V4R' in filled) && filled['V4']) {
      filled['V4R'] = filled['V4'].map(v => -v * 0.6); // Right-sided, inverted
    }
    if (!('V7' in filled) && filled['V6']) {
      filled['V7'] = filled['V6'].map(v => v * 0.8); // Posterior continuation
    }
    if (!('V8' in filled) && filled['V6']) {
      filled['V8'] = filled['V6'].map(v => v * 0.6);
    }
    if (!('V9' in filled) && filled['V6']) {
      filled['V9'] = filled['V6'].map(v => v * 0.4);
    }
  }

  // Ensure standard 12 leads exist (always required)
  for (const lead of STANDARD_LEADS) {
    if (!(lead in filled)) {
      filled[lead] = new Array(sampleCount).fill(0);
    }
  }

  // Only include pediatric leads if any were extracted
  if (hasPediatricLeads) {
    for (const lead of PEDIATRIC_LEADS) {
      if (!(lead in filled)) {
        filled[lead] = new Array(sampleCount).fill(0);
      }
    }
  }

  return filled;
}

async function loadImageFromURL(url) {
  showStatus('Loading image from URL...', 'info', 0);

  try {
    const img = new Image();
    if (!url.startsWith('data:')) {
      img.crossOrigin = 'anonymous';
    }

    img.onload = function() {
      const name = url.startsWith('data:') ? 'pasted-image.png' : (url.split('/').pop() || 'web-image.png');
      processImportedImage(img, name);
    };

    img.onerror = () => {
      showStatus('Could not load image (CORS). Try: copy image, then Cmd+V', 'warning');
    };

    img.src = url;

  } catch (err) {
    showStatus('Failed to load image: ' + err.message, 'error');
  }
}

// Also handle pasting URLs
document.addEventListener('paste', (e) => {
  const text = e.clipboardData?.getData('text/plain');
  if (text && text.match(/^https?:\/\/.*\.(png|jpg|jpeg|gif|webp)/i)) {
    e.preventDefault();
    loadImageFromURL(text);
  }
}, true);

window.startCalibration = function() {
  if (!imageMode || !uploadedImage) {
    showStatus('Upload an image first', 'warning');
    return;
  }

  // First try auto-detection
  showStatus('Detecting grid automatically...', 'info', 0);

  const detected = detectGridSpacing(uploadedImage);

  if (detected && detected.confidence > 0.7) {
    // Auto-calibration succeeded
    imageCalibration = {
      pxPerMm: detected.pxPerMm,
      calibrated: true,
      method: 'auto'
    };

    const statusEl = document.getElementById('calibrationStatus');
    statusEl.style.display = 'block';
    statusEl.innerHTML = `<strong>Auto-calibrated:</strong> ${detected.pxPerMm.toFixed(2)} px/mm (confidence: ${(detected.confidence * 100).toFixed(0)}%)`;
    statusEl.style.color = '#2e7d32';

    document.getElementById('calibrateBtn').textContent = 'Manual Calibrate';
    showStatus(`Auto-calibration complete: ${detected.pxPerMm.toFixed(2)} px/mm`, 'success');
    updateCaliperList();
    redraw();
    return;
  }

  // Fall back to manual calibration
  calibrationMode = true;
  calibrationPoint1 = null;
  calipersActive = false;

  const statusEl = document.getElementById('calibrationStatus');
  statusEl.style.display = 'block';
  statusEl.innerHTML = '<strong>Step 1:</strong> Click the LEFT edge of 5 big grid boxes (25mm)';
  statusEl.style.color = '#1b6dff';

  document.getElementById('calibrateBtn').textContent = 'Cancel Calibration';
  document.getElementById('calibrateBtn').onclick = cancelCalibration;
  document.getElementById('c').style.cursor = 'crosshair';

  showStatus('Auto-detection failed. Click two points exactly 5 big boxes apart.', 'info', 0);
  redraw();
};

// ============================================================================
// ECG TRACE EXTRACTION (WebPlotDigitizer-style averaging window algorithm)
// ============================================================================

/**
 * Extract ECG trace from uploaded image using averaging window algorithm
 * Based on the approach used by WebPlotDigitizer (AGPL v3)
 */
window.extractTraceFromImage = function() {
  if (!uploadedImage) {
    showStatus('Upload an image first', 'warning');
    return;
  }

  showStatus('Extracting trace...', 'info');

  // Create canvas to get image data
  const canvas = document.createElement('canvas');
  canvas.width = uploadedImage.width;
  canvas.height = uploadedImage.height;
  const ctx = canvas.getContext('2d');
  ctx.drawImage(uploadedImage, 0, 0);
  const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);

  try {
    // Step 1: Detect trace pixels (dark pixels that aren't grid)
    const tracePixels = detectTracePixels(imageData);

    if (tracePixels.size < 100) {
      showStatus('Could not detect trace. Try adjusting image contrast.', 'error');
      return;
    }

    // Step 2: Run averaging window algorithm
    const rawPoints = averagingWindowExtract(tracePixels, canvas.width, canvas.height);

    if (rawPoints.length < 50) {
      showStatus('Extraction failed - not enough trace points detected', 'error');
      return;
    }

    // Step 3: Convert to physical units using calibration
    const pxPerMm = imageCalibration?.pxPerMm || estimatePxPerMm(canvas.width, canvas.height);
    const mmPerSec = parseFloat(document.getElementById('importSpeed').value) || 25;
    const mmPerMV = parseFloat(document.getElementById('importGain').value) || 10;

    // Convert pixels to time (seconds) and voltage (mV)
    const pxPerSec = pxPerMm * mmPerSec;
    const pxPerMV = pxPerMm * mmPerMV;

    // Find baseline (median y value) for voltage reference
    const yValues = rawPoints.map(p => p.y);
    yValues.sort((a, b) => a - b);
    const baselineY = yValues[Math.floor(yValues.length / 2)];

    // Convert points to time/voltage pairs
    const timeVoltage = rawPoints.map(p => ({
      time: p.x / pxPerSec,
      voltage: (baselineY - p.y) / pxPerMV  // Invert Y (screen coords are top-down)
    }));

    // Sort by time
    timeVoltage.sort((a, b) => a.time - b.time);

    // Resample to uniform 500 Hz
    const fs = 500;
    const duration = timeVoltage[timeVoltage.length - 1].time;
    const numSamples = Math.round(duration * fs);
    const resampled = new Float32Array(numSamples);

    for (let i = 0; i < numSamples; i++) {
      const t = i / fs;
      // Find surrounding points for linear interpolation
      let j = 0;
      while (j < timeVoltage.length - 1 && timeVoltage[j + 1].time < t) j++;

      if (j >= timeVoltage.length - 1) {
        resampled[i] = timeVoltage[timeVoltage.length - 1].voltage;
      } else {
        const t0 = timeVoltage[j].time, t1 = timeVoltage[j + 1].time;
        const v0 = timeVoltage[j].voltage, v1 = timeVoltage[j + 1].voltage;
        const alpha = (t - t0) / (t1 - t0 || 1);
        resampled[i] = v0 + alpha * (v1 - v0);
      }
    }

    // Convert to ÂµV and create leads object
    const lead_uV = Array.from(resampled).map(v => v * 1000);

    // Create ECG data structure (single lead imported as Lead II)
    const leads_uV = { 'II': lead_uV };

    // Fill in approximate versions of other leads
    leads_uV['I'] = lead_uV.map(v => v * 0.6);
    leads_uV['III'] = lead_uV.map((v, i) => leads_uV['II'][i] - leads_uV['I'][i]);
    leads_uV['aVR'] = lead_uV.map((v, i) => -(leads_uV['I'][i] + leads_uV['II'][i]) / 2);
    leads_uV['aVL'] = lead_uV.map((v, i) => leads_uV['I'][i] - leads_uV['II'][i] / 2);
    leads_uV['aVF'] = lead_uV.map((v, i) => leads_uV['II'][i] - leads_uV['I'][i] / 2);
    leads_uV['V1'] = lead_uV.map(v => v * -0.3);
    leads_uV['V2'] = lead_uV.map(v => v * -0.1);
    leads_uV['V3'] = lead_uV.map(v => v * 0.2);
    leads_uV['V4'] = lead_uV.map(v => v * 0.5);
    leads_uV['V5'] = lead_uV.map(v => v * 0.7);
    leads_uV['V6'] = lead_uV.map(v => v * 0.8);

    // Set as current ECG data
    ecgData = {
      fs: fs,
      duration_s: duration,
      leads_uV: leads_uV,
      targets: {
        synthetic: false,
        source: 'image_extraction',
        filename: uploadedImageName
      },
      integrity: {
        extraction_points: rawPoints.length,
        resampled_points: numSamples
      }
    };

    imageMode = false;
    uploadedImage = null;
    document.getElementById('calibrationControls').style.display = 'none';

    updateAfterLoad();
    showStatus(`Extracted ${rawPoints.length} points â†’ ${duration.toFixed(1)}s ECG at 500 Hz`, 'success');

  } catch (err) {
    console.error('Extraction error:', err);
    showStatus('Extraction failed: ' + err.message, 'error');
  }
};

/**
 * Detect trace pixels (foreground) vs background/grid
 * Returns Set of pixel indices that are part of the trace
 */
function detectTracePixels(imageData) {
  const { data, width, height } = imageData;
  const tracePixels = new Set();

  // Grid colors to exclude (red, pink, green, blue variations)
  const isGridColor = (r, g, b) => {
    // Red/pink grid lines
    if (r > 150 && r > g * 1.3 && r > b * 1.3) return true;
    // Green grid lines
    if (g > 150 && g > r * 1.3 && g > b * 1.2) return true;
    // Blue grid lines
    if (b > 150 && b > r * 1.3 && b > g * 1.2) return true;
    // Light pink/salmon
    if (r > 200 && g > 150 && g < 220 && b > 150 && b < 220) return true;
    return false;
  };

  // Calculate brightness threshold for trace detection
  // Trace is typically the darkest element
  let brightnessHist = new Array(256).fill(0);

  for (let i = 0; i < data.length; i += 4) {
    const r = data[i], g = data[i + 1], b = data[i + 2];
    if (!isGridColor(r, g, b)) {
      const brightness = Math.round((r + g + b) / 3);
      brightnessHist[brightness]++;
    }
  }

  // Find the darkest significant peak (trace pixels)
  // Look for threshold where we capture trace but not background
  let threshold = 80; // Default
  let cumulative = 0;
  const totalPixels = (data.length / 4);

  for (let i = 0; i < 256; i++) {
    cumulative += brightnessHist[i];
    // Trace typically occupies 0.5-5% of non-grid pixels
    if (cumulative > totalPixels * 0.005 && cumulative < totalPixels * 0.15) {
      threshold = i;
      break;
    }
  }

  // Collect trace pixels
  for (let y = 0; y < height; y++) {
    for (let x = 0; x < width; x++) {
      const i = (y * width + x) * 4;
      const r = data[i], g = data[i + 1], b = data[i + 2];

      // Skip grid colors
      if (isGridColor(r, g, b)) continue;

      // Check if dark enough to be trace
      const brightness = (r + g + b) / 3;
      if (brightness <= threshold) {
        tracePixels.add(y * width + x);
      }
    }
  }

  return tracePixels;
}

/**
 * Averaging Window Algorithm for trace extraction
 * Scans columns, groups vertically-adjacent trace pixels, averages positions
 */
function averagingWindowExtract(tracePixels, width, height, xStep = 2, yStep = 5) {
  const points = [];

  // For each column, find trace pixels and average their y-positions
  for (let x = 0; x < width; x++) {
    let blobs = [];
    let currentBlob = null;

    // Scan vertically for trace pixels
    for (let y = 0; y < height; y++) {
      const idx = y * width + x;
      if (tracePixels.has(idx)) {
        if (currentBlob === null || y > currentBlob.lastY + yStep) {
          // Start new blob
          if (currentBlob !== null) blobs.push(currentBlob);
          currentBlob = { sumY: y, count: 1, lastY: y };
        } else {
          // Extend current blob
          currentBlob.sumY += y;
          currentBlob.count++;
          currentBlob.lastY = y;
        }
      }
    }
    if (currentBlob !== null) blobs.push(currentBlob);

    // Add points for each blob (use center of blob)
    for (const blob of blobs) {
      points.push({
        x: x + 0.5,
        y: blob.sumY / blob.count + 0.5,
        weight: blob.count
      });
    }
  }

  // Merge nearby points using xStep window
  const mergedPoints = [];
  const used = new Set();

  for (let i = 0; i < points.length; i++) {
    if (used.has(i)) continue;

    let sumX = points[i].x;
    let sumY = points[i].y;
    let count = 1;

    // Find nearby points to merge
    for (let j = i + 1; j < points.length; j++) {
      if (used.has(j)) continue;
      if (points[j].x > points[i].x + xStep * 2) break;

      if (Math.abs(points[j].x - points[i].x) <= xStep &&
          Math.abs(points[j].y - points[i].y) <= yStep) {
        sumX += points[j].x;
        sumY += points[j].y;
        count++;
        used.add(j);
      }
    }

    used.add(i);
    mergedPoints.push({ x: sumX / count, y: sumY / count });
  }

  return mergedPoints;
}

/**
 * Estimate pixels per mm if no calibration available
 * Based on typical ECG paper dimensions
 */
function estimatePxPerMm(imageWidth, imageHeight) {
  // Standard 12-lead ECG is ~250mm wide at 25mm/s for 10s
  // Estimate based on typical image sizes
  if (imageWidth > 2000) return 8;   // High-res scan
  if (imageWidth > 1000) return 4;   // Medium res
  return 2;  // Low res
}

// Parse CSV from WebPlotDigitizer or similar tools
function parseCSVtoECG(csvText, filename) {
  try {
    const lines = csvText.trim().split(/\r?\n/);
    if (lines.length < 10) {
      showStatus('CSV file too short - need at least 10 data points', 'error');
      return null;
    }

    // Detect delimiter (comma or tab)
    const delimiter = lines[0].includes('\t') ? '\t' : ',';

    // Parse header row to detect columns
    const headerRow = lines[0].split(delimiter).map(s => s.trim().toLowerCase());

    // Check if first row is a header or data
    const firstRowIsHeader = headerRow.some(h =>
      /^(time|t|x|seconds?|ms|lead|i|ii|iii|avr|avl|avf|v[1-6])$/i.test(h)
    );

    const dataStartRow = firstRowIsHeader ? 1 : 0;

    // Parse all data rows
    const rows = [];
    for (let i = dataStartRow; i < lines.length; i++) {
      const values = lines[i].split(delimiter).map(s => parseFloat(s.trim()));
      if (values.length >= 2 && values.every(v => !isNaN(v))) {
        rows.push(values);
      }
    }

    if (rows.length < 10) {
      showStatus('CSV has too few valid data rows', 'error');
      return null;
    }

    // Determine format based on header or column count
    const numCols = rows[0].length;

    // Standard lead names for multi-column format
    const LEAD_NAMES = ['I', 'II', 'III', 'aVR', 'aVL', 'aVF', 'V1', 'V2', 'V3', 'V4', 'V5', 'V6'];

    let leads_uV = {};
    let fs = 500; // Target sample rate
    let duration_s;

    if (numCols === 2) {
      // WebPlotDigitizer format: time, voltage (single lead)
      // Time is typically in seconds, voltage in mV
      const times = rows.map(r => r[0]);
      const voltages = rows.map(r => r[1]);

      // Detect time units (seconds vs milliseconds)
      const timeRange = Math.max(...times) - Math.min(...times);
      const timeScale = timeRange > 100 ? 0.001 : 1; // If range > 100, assume ms

      // Normalize time to start at 0
      const minTime = Math.min(...times);
      const normalizedTimes = times.map(t => (t - minTime) * timeScale);
      duration_s = Math.max(...normalizedTimes);

      // Detect voltage units (mV vs ÂµV)
      const maxV = Math.max(...voltages.map(Math.abs));
      const voltageScale = maxV > 100 ? 1 : 1000; // If max > 100, assume already ÂµV

      // Resample to uniform 500 Hz
      const numSamples = Math.round(duration_s * fs);
      const resampledVoltages = new Float32Array(numSamples);

      for (let i = 0; i < numSamples; i++) {
        const t = i / fs;
        // Find surrounding points for linear interpolation
        let j = 0;
        while (j < normalizedTimes.length - 1 && normalizedTimes[j + 1] < t) j++;

        if (j >= normalizedTimes.length - 1) {
          resampledVoltages[i] = voltages[voltages.length - 1] * voltageScale;
        } else {
          const t0 = normalizedTimes[j], t1 = normalizedTimes[j + 1];
          const v0 = voltages[j], v1 = voltages[j + 1];
          const alpha = (t - t0) / (t1 - t0 || 1);
          resampledVoltages[i] = (v0 + alpha * (v1 - v0)) * voltageScale;
        }
      }

      // Single lead - assign to Lead II (most common for rhythm strips)
      leads_uV['II'] = Array.from(resampledVoltages);

      // Generate synthetic versions of other leads based on Lead II
      // This is approximate but allows the UI to work
      leads_uV['I'] = leads_uV['II'].map(v => v * 0.6);
      leads_uV['III'] = leads_uV['II'].map((v, i) => leads_uV['II'][i] - leads_uV['I'][i]);
      leads_uV['aVR'] = leads_uV['II'].map((v, i) => -(leads_uV['I'][i] + leads_uV['II'][i]) / 2);
      leads_uV['aVL'] = leads_uV['II'].map((v, i) => leads_uV['I'][i] - leads_uV['II'][i] / 2);
      leads_uV['aVF'] = leads_uV['II'].map((v, i) => leads_uV['II'][i] - leads_uV['I'][i] / 2);
      // Precordial leads - approximate
      leads_uV['V1'] = leads_uV['II'].map(v => v * -0.3);
      leads_uV['V2'] = leads_uV['II'].map(v => v * -0.1);
      leads_uV['V3'] = leads_uV['II'].map(v => v * 0.2);
      leads_uV['V4'] = leads_uV['II'].map(v => v * 0.5);
      leads_uV['V5'] = leads_uV['II'].map(v => v * 0.7);
      leads_uV['V6'] = leads_uV['II'].map(v => v * 0.8);

      showStatus(`Imported single-lead CSV (${rows.length} points) as Lead II`, 'success');

    } else if (numCols >= 3) {
      // Multi-column format: time + multiple leads
      // Try to detect which columns are which leads from header
      let leadColumns = {};

      if (firstRowIsHeader) {
        headerRow.forEach((h, idx) => {
          if (idx === 0) return; // Skip time column
          const leadMatch = h.match(/^(i{1,3}|avr|avl|avf|v[1-6])$/i);
          if (leadMatch) {
            let leadName = leadMatch[1].toUpperCase();
            // Convert roman numerals
            if (leadName === 'I') leadName = 'I';
            else if (leadName === 'II') leadName = 'II';
            else if (leadName === 'III') leadName = 'III';
            leadColumns[leadName] = idx;
          }
        });
      }

      // If no headers matched, assume columns 1-12 are leads I-V6
      if (Object.keys(leadColumns).length === 0) {
        for (let i = 1; i < Math.min(numCols, 13); i++) {
          leadColumns[LEAD_NAMES[i - 1]] = i;
        }
      }

      // Extract time column
      const times = rows.map(r => r[0]);
      const timeRange = Math.max(...times) - Math.min(...times);
      const timeScale = timeRange > 100 ? 0.001 : 1;
      const minTime = Math.min(...times);
      const normalizedTimes = times.map(t => (t - minTime) * timeScale);
      duration_s = Math.max(...normalizedTimes);

      // Detect voltage scale from first lead's data
      const firstLeadIdx = Object.values(leadColumns)[0];
      const firstLeadValues = rows.map(r => r[firstLeadIdx]);
      const maxV = Math.max(...firstLeadValues.map(Math.abs));
      const voltageScale = maxV > 100 ? 1 : 1000;

      // Resample each lead
      const numSamples = Math.round(duration_s * fs);

      for (const [leadName, colIdx] of Object.entries(leadColumns)) {
        const voltages = rows.map(r => r[colIdx]);
        const resampled = new Float32Array(numSamples);

        for (let i = 0; i < numSamples; i++) {
          const t = i / fs;
          let j = 0;
          while (j < normalizedTimes.length - 1 && normalizedTimes[j + 1] < t) j++;

          if (j >= normalizedTimes.length - 1) {
            resampled[i] = voltages[voltages.length - 1] * voltageScale;
          } else {
            const t0 = normalizedTimes[j], t1 = normalizedTimes[j + 1];
            const v0 = voltages[j], v1 = voltages[j + 1];
            const alpha = (t - t0) / (t1 - t0 || 1);
            resampled[i] = (v0 + alpha * (v1 - v0)) * voltageScale;
          }
        }

        leads_uV[leadName] = Array.from(resampled);
      }

      // Fill in missing leads if we have at least limb leads
      const hasI = 'I' in leads_uV;
      const hasII = 'II' in leads_uV;
      const hasIII = 'III' in leads_uV;

      if (hasI && hasII && !hasIII) {
        leads_uV['III'] = leads_uV['I'].map((v, i) => leads_uV['II'][i] - v);
      }
      if (!('aVR' in leads_uV) && hasI && hasII) {
        leads_uV['aVR'] = leads_uV['I'].map((v, i) => -(v + leads_uV['II'][i]) / 2);
      }
      if (!('aVL' in leads_uV) && hasI && hasII) {
        leads_uV['aVL'] = leads_uV['I'].map((v, i) => v - leads_uV['II'][i] / 2);
      }
      if (!('aVF' in leads_uV) && hasI && hasII) {
        leads_uV['aVF'] = leads_uV['II'].map((v, i) => v - leads_uV['I'][i] / 2);
      }

      // Fill in missing precordial leads with zeros
      for (const lead of LEAD_NAMES) {
        if (!(lead in leads_uV)) {
          leads_uV[lead] = new Array(numSamples).fill(0);
        }
      }

      showStatus(`Imported ${Object.keys(leadColumns).length}-lead CSV (${rows.length} points)`, 'success');
    }

    // Build ECG data structure
    const ecgData = {
      fs: fs,
      duration_s: duration_s,
      leads_uV: leads_uV,
      targets: {
        synthetic: false,
        imported: true,
        source: 'csv',
        filename: filename,
        dx: 'Imported ECG'
      },
      integrity: {
        format: 'csv_import',
        original_points: rows.length,
        resampled_to_hz: fs
      }
    };

    return ecgData;

  } catch (err) {
    console.error('CSV parse error:', err);
    showStatus('Failed to parse CSV: ' + err.message, 'error');
    return null;
  }
}

window.cancelCalibration = function() {
  calibrationMode = false;
  calibrationPoint1 = null;

  const statusEl = document.getElementById('calibrationStatus');
  statusEl.style.display = 'none';

  document.getElementById('calibrateBtn').textContent = 'Calibrate Grid';
  document.getElementById('calibrateBtn').onclick = startCalibration;
  document.getElementById('c').style.cursor = 'default';

  clearStatus();
  redraw();
};

function handleCalibrationClick(x, y) {
  const statusEl = document.getElementById('calibrationStatus');

  if (!calibrationPoint1) {
    // First point
    calibrationPoint1 = { x, y };
    statusEl.innerHTML = '<strong>Step 2:</strong> Click the RIGHT edge of those same 5 boxes';

    // Draw marker at first point
    redraw();
    const canvas = document.getElementById('c');
    const ctx = canvas.getContext('2d');
    ctx.fillStyle = '#1b6dff';
    ctx.beginPath();
    ctx.arc(x, y, 6, 0, Math.PI * 2);
    ctx.fill();
    ctx.strokeStyle = '#fff';
    ctx.lineWidth = 2;
    ctx.stroke();

  } else {
    // Second point - calculate calibration
    const dx = Math.abs(x - calibrationPoint1.x);

    if (dx < 20) {
      showStatus('Points too close together. Try again.', 'error');
      calibrationPoint1 = null;
      statusEl.innerHTML = '<strong>Step 1:</strong> Click the LEFT edge of 5 big grid boxes (25mm)';
      return;
    }

    // 5 big boxes = 25mm
    const pxPerMm = dx / 25;

    // Store calibration
    imageCalibration = {
      ...imageCalibration,
      pxPerMm: pxPerMm,
      calibrated: true
    };

    // Complete calibration
    calibrationMode = false;
    calibrationPoint1 = null;

    statusEl.innerHTML = `<strong>Calibrated:</strong> ${pxPerMm.toFixed(2)} px/mm (${(pxPerMm * 25).toFixed(0)}px = 25mm)`;
    statusEl.style.color = '#2e7d32';

    document.getElementById('calibrateBtn').textContent = 'Recalibrate';
    document.getElementById('calibrateBtn').onclick = startCalibration;
    document.getElementById('c').style.cursor = 'default';

    showStatus(`Calibration complete: ${pxPerMm.toFixed(2)} pixels/mm â€” measurements are now accurate`, 'success');
    redraw();
  }
}

// ============================================================================
// UPDATE AFTER LOAD
// ============================================================================

function updateAfterLoad() {
  if (!ecgData) return;

  // Update badge
  const badge = document.getElementById('sourceBadge');
  if (ecgData.targets?.synthetic) {
    badge.textContent = 'SYNTHETIC';
    badge.className = 'header-badge badge-synth';
  } else {
    badge.textContent = 'REAL';
    badge.className = 'header-badge badge-real';
  }

  // Compute measurements
  computeMeasurements();

  // Update case info
  const dx = ecgData.targets?.dx || 'Unknown';
  const age = ecgData.targets?.age_years;
  const sex = ecgData.targets?.sex;
  const sexLabel = sex === 'male' ? 'M' : sex === 'female' ? 'F' : '';
  const ageStr = age != null ? `${age.toFixed(0)}y` : '';
  const demo = [ageStr, sexLabel].filter(Boolean).join(' ');
  document.getElementById('caseInfo').textContent = demo
    ? `${dx}, ${demo}`
    : dx;

  // Draw
  redraw();
}

// ============================================================================
// MEASUREMENTS
// ============================================================================

function computeMeasurements() {
  if (!ecgData) return;

  const { fs, leads_uV } = ecgData;
  const leadII = leads_uV.II || leads_uV['II'];
  if (!leadII) return;

  // Detect R peaks
  const rPeaks = detectRPeaks(leadII, fs);
  if (rPeaks.length < 2) return;

  // Compute HR from RR intervals
  const rr = [];
  for (let i = 1; i < rPeaks.length; i++) {
    rr.push((rPeaks[i] - rPeaks[i-1]) / fs);
  }
  const meanRR = mean(rr);
  const hr = 60 / meanRR;

  // Build median beat and compute intervals
  const medianBeat = buildMedianBeat(leadII, rPeaks, fs);
  const fids = fiducialsFromMedian(medianBeat, fs);
  const globalMeas = computeGlobalMeasurements(fids, fs, meanRR);

  measurements = {
    hr,
    pr: globalMeas.PR_ms,
    qrs: globalMeas.QRS_ms,
    qt: globalMeas.QT_ms,
    qtcBazett: globalMeas.QTc_Bazett_ms,
    qtcFrid: globalMeas.QTc_Fridericia_ms,
    axes: computeAxesFromMedian ? computeAxesFromMedian(leads_uV, rPeaks, fs) : null,
    rPeaks,
    fids,
    medianBeat
  };

  // Update display
  const age = ecgData.targets?.age_years || 8;
  document.getElementById('m_hr').innerHTML = fmtMeasure(hr, 'bpm', 'HR', age);
  document.getElementById('m_pr').innerHTML = fmtMeasure(measurements.pr, 'ms', 'PR', age);
  document.getElementById('m_qrs').innerHTML = fmtMeasure(measurements.qrs, 'ms', 'QRS', age);
  document.getElementById('m_qt').textContent = measurements.qt ? `${Math.round(measurements.qt)} ms` : 'â€”';
  document.getElementById('m_qtc').innerHTML = fmtMeasure(measurements.qtcBazett, 'ms', 'QTc', age);

  if (measurements.axes) {
    const { P, QRS, T } = measurements.axes;
    document.getElementById('m_axes').textContent = `${Math.round(P)}Â° / ${Math.round(QRS)}Â° / ${Math.round(T)}Â°`;
  }

  document.getElementById('m_dx').textContent = ecgData.targets?.dx || 'â€”';
  const ageVal = ecgData.targets?.age_years;
  const sexVal = ecgData.targets?.sex;
  const sexStr = sexVal === 'male' ? 'M' : sexVal === 'female' ? 'F' : '';
  const ageDisplay = ageVal != null ? `${ageVal.toFixed(0)}y` : '';
  document.getElementById('m_age').textContent = [ageDisplay, sexStr].filter(Boolean).join(' ') || 'â€”';
}

function fmtMeasure(value, unit, param, age) {
  if (value == null) return 'â€”';
  const valStr = unit === 'bpm' ? `${Math.round(value)} bpm` : `${Math.round(value)} ms`;
  // Could add age-appropriate normal range checking here
  return valStr;
}

// ============================================================================
// DRAWING
// ============================================================================

function redraw() {
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');
  const dpr = window.devicePixelRatio || 1;

  // Set canvas size
  const rect = canvas.getBoundingClientRect();
  canvas.width = rect.width * dpr;
  canvas.height = rect.height * dpr;
  ctx.scale(dpr, dpr);

  // Clear
  ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--paper');
  ctx.fillRect(0, 0, rect.width, rect.height);

  // Handle uploaded image mode
  if (imageMode && uploadedImage) {
    drawUploadedImage(ctx, rect.width, rect.height);
    return;
  }

  if (!ecgData) {
    ctx.fillStyle = '#888';
    ctx.font = '16px system-ui';
    ctx.textAlign = 'center';
    ctx.fillText('Generate or load an ECG to begin', rect.width / 2, rect.height / 2);
    return;
  }

  const layout = document.getElementById('layout').value;
  const speed = parseInt(document.getElementById('speed').value);
  const gain = parseInt(document.getElementById('gain').value);
  const pxmm = parseInt(document.getElementById('pxmm').value);
  const showFid = document.getElementById('fid').checked && currentMode === 'teach';

  const { fs, leads_uV } = ecgData;
  const mmPerSec = speed;
  const mmPerMV = gain;
  const pxPerMm = pxmm;

  // Draw based on layout
  if (layout === 'stacked') {
    drawStackedLayout(ctx, rect.width, rect.height, leads_uV, fs, pxPerMm, mmPerSec, mmPerMV, showFid);
  } else {
    draw12LeadLayout(ctx, rect.width, rect.height, leads_uV, fs, pxPerMm, mmPerSec, mmPerMV, showFid);
  }
}

function drawUploadedImage(ctx, w, h) {
  const img = uploadedImage;
  const speed = parseInt(document.getElementById('importSpeed')?.value || 25);
  const gain = parseInt(document.getElementById('importGain')?.value || 10);
  const pxmm = parseInt(document.getElementById('pxmm')?.value || 4);

  // Draw grid first (helps with calibration)
  drawGrid(ctx, w, h, pxmm);

  // Calculate scaling to fit image while maintaining aspect ratio
  const imgAspect = img.width / img.height;
  const canvasAspect = w / h;

  let drawW, drawH, offsetX, offsetY;

  if (imgAspect > canvasAspect) {
    // Image is wider than canvas
    drawW = w;
    drawH = w / imgAspect;
    offsetX = 0;
    offsetY = (h - drawH) / 2;
  } else {
    // Image is taller than canvas
    drawH = h;
    drawW = h * imgAspect;
    offsetX = (w - drawW) / 2;
    offsetY = 0;
  }

  // Draw the image
  ctx.drawImage(img, offsetX, offsetY, drawW, drawH);

  // Draw info overlay
  ctx.fillStyle = 'rgba(0,0,0,0.7)';
  ctx.fillRect(5, 5, 180, 50);
  ctx.fillStyle = '#fff';
  ctx.font = '11px system-ui';
  ctx.textAlign = 'left';
  ctx.fillText(`Speed: ${speed} mm/s | Gain: ${gain} mm/mV`, 10, 22);
  ctx.fillText(`Image: ${uploadedImageName || 'Unknown'}`, 10, 38);

  // Draw calipers on top
  drawAllCalipers(ctx, w, h);

  // Draw in-progress caliper
  if (activeCaliperPoint && lastMousePos) {
    let endPoint = lastMousePos;
    if (shiftHeld) {
      endPoint = constrainPoint(endPoint.x, endPoint.y, activeCaliperPoint.x, activeCaliperPoint.y, true);
    }
    const color = CALIPER_COLORS[nextCaliperColor % CALIPER_COLORS.length];
    drawSingleCaliper(ctx, activeCaliperPoint, endPoint, color, false, null);
  }
}

function drawStackedLayout(ctx, w, h, leads, fs, pxPerMm, mmPerSec, mmPerMV, showFid) {
  const leadOrder = ['I', 'II', 'III', 'aVR', 'aVL', 'aVF', 'V1', 'V2', 'V3', 'V4', 'V5', 'V6'];
  const available = leadOrder.filter(l => leads[l]);
  const rowCount = available.length;
  const rowH = h / rowCount;

  // Draw grid
  drawGrid(ctx, w, h, pxPerMm);

  const pxPerSample = (pxPerMm * mmPerSec) / fs;
  const uvPerPx = 1000 / (pxPerMm * mmPerMV);

  // Check if we should show reference overlay
  const showOverlay = document.getElementById('showOverlay')?.checked && referenceECG;
  const showDiff = document.getElementById('showDiff')?.checked;

  // Draw reference ECG first (underneath) if overlay enabled
  if (showOverlay && referenceECG?.leads_uV) {
    const refLeads = referenceECG.leads_uV;
    const refFs = referenceECG.fs || fs;
    const refPxPerSample = (pxPerMm * mmPerSec) / refFs;

    available.forEach((lead, i) => {
      if (!refLeads[lead]) return;
      const y0 = (i + 0.5) * rowH;
      const signal = refLeads[lead];

      ctx.strokeStyle = 'rgba(0, 100, 200, 0.5)';
      ctx.lineWidth = 1.5;
      ctx.lineCap = 'round';
      ctx.lineJoin = 'round';
      ctx.beginPath();

      for (let j = 0; j < signal.length; j++) {
        const x = 40 + j * refPxPerSample + panOffset;
        if (x < 0 || x > w) continue;
        const yVal = y0 - signal[j] / uvPerPx;
        if (j === 0) ctx.moveTo(x, yVal);
        else ctx.lineTo(x, yVal);
      }
      ctx.stroke();
    });
  }

  // Draw each lead (current ECG)
  available.forEach((lead, i) => {
    const y0 = (i + 0.5) * rowH;
    const signal = leads[lead];

    // Lead label
    ctx.fillStyle = '#333';
    ctx.font = 'bold 11px "Courier New", Consolas, monospace';
    ctx.textAlign = 'left';
    ctx.fillText(lead, 8, y0 - rowH/2 + 14);

    // Determine trace color based on diff highlighting
    let strokeColor = '#1a1a1a';
    if (showDiff && showOverlay && referenceECG?.leads_uV?.[lead]) {
      // Calculate RMS difference for this lead
      const refSignal = referenceECG.leads_uV[lead];
      const minLen = Math.min(signal.length, refSignal.length);
      let sumSq = 0;
      for (let k = 0; k < minLen; k++) {
        sumSq += Math.pow(signal[k] - refSignal[k], 2);
      }
      const rms = Math.sqrt(sumSq / minLen);
      // Color based on difference magnitude (red = high, green = low)
      if (rms > 300) strokeColor = '#c62828';      // Major difference (red)
      else if (rms > 100) strokeColor = '#ef6c00'; // Moderate (orange)
      else strokeColor = '#2e7d32';                // Similar (green)
    }

    // Draw trace
    ctx.strokeStyle = strokeColor;
    ctx.lineWidth = 1.3;
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';
    ctx.beginPath();

    for (let j = 0; j < signal.length; j++) {
      const x = 40 + j * pxPerSample + panOffset;
      if (x < 0 || x > w) continue;
      const yVal = y0 - signal[j] / uvPerPx;
      if (j === 0) ctx.moveTo(x, yVal);
      else ctx.lineTo(x, yVal);
    }
    ctx.stroke();
  });

  // Draw fiducials if enabled
  if (showFid && measurements?.fids && measurements?.rPeaks) {
    drawFiducials(ctx, leads.II || leads['II'], fs, measurements, h / 2, pxPerMm * mmPerSec / fs);
  }

  // Draw calipers (advanced system)
  drawAllCalipers(ctx, w, h);

  // Draw legend if overlay is active
  if (showOverlay) {
    ctx.font = '10px system-ui';
    ctx.fillStyle = 'rgba(0, 100, 200, 0.8)';
    ctx.fillText('Reference', w - 70, 15);
    ctx.fillStyle = '#1a1a1a';
    ctx.fillText('Current', w - 70, 28);
  }
}

function draw12LeadLayout(ctx, w, h, leads, fs, pxPerMm, mmPerSec, mmPerMV, showFid) {
  // Simplified 12-lead layout (3x4 grid + rhythm strip)
  drawGrid(ctx, w, h, pxPerMm);

  const leadGroups = [
    ['I', 'aVR', 'V1', 'V4'],
    ['II', 'aVL', 'V2', 'V5'],
    ['III', 'aVF', 'V3', 'V6']
  ];

  const colW = w / 4;
  const rowH = (h - 100) / 3;
  const rhythmH = 80;

  // Check if we should show reference overlay
  const showOverlay = document.getElementById('showOverlay')?.checked && referenceECG;
  const refLeads = referenceECG?.leads_uV;
  const refFs = referenceECG?.fs || fs;

  // Helper to draw a trace segment
  const drawTrace = (signal, x0, y0, ci, samplesPerCol, pxPerSample, uvPerPx, color) => {
    const startSample = ci * samplesPerCol;
    const endSample = Math.min(startSample + samplesPerCol, signal.length);
    ctx.strokeStyle = color;
    ctx.lineWidth = 1.3;
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';
    ctx.beginPath();
    for (let j = startSample; j < endSample; j++) {
      const x = x0 + (j - startSample) * pxPerSample;
      const yVal = y0 - signal[j] / uvPerPx;
      if (j === startSample) ctx.moveTo(x, yVal);
      else ctx.lineTo(x, yVal);
    }
    ctx.stroke();
  };

  leadGroups.forEach((row, ri) => {
    row.forEach((lead, ci) => {
      if (!leads[lead]) return;
      const x0 = ci * colW + 10;
      const y0 = ri * rowH + rowH / 2;

      // Label
      ctx.fillStyle = '#333';
      ctx.font = 'bold 10px "Courier New", Consolas, monospace';
      ctx.fillText(lead, x0, ri * rowH + 14);

      const signal = leads[lead];
      const samplesPerCol = Math.floor(2.5 * fs);
      const pxPerSample = (colW - 20) / samplesPerCol;
      const uvPerPx = 1000 / (pxPerMm * mmPerMV);

      // Draw reference first if overlay enabled
      if (showOverlay && refLeads?.[lead]) {
        const refSamplesPerCol = Math.floor(2.5 * refFs);
        const refPxPerSample = (colW - 20) / refSamplesPerCol;
        drawTrace(refLeads[lead], x0, y0, ci, refSamplesPerCol, refPxPerSample, uvPerPx, 'rgba(0, 100, 200, 0.5)');
      }

      // Draw current trace
      drawTrace(signal, x0, y0, ci, samplesPerCol, pxPerSample, uvPerPx, '#1a1a1a');
    });
  });

  // Rhythm strip (Lead II, full duration)
  const rhythmY = h - rhythmH / 2 - 10;
  ctx.fillStyle = '#333';
  ctx.font = 'bold 10px "Courier New", Consolas, monospace';
  ctx.fillText('II (rhythm)', 10, h - rhythmH);

  const uvPerPx = 1000 / (pxPerMm * mmPerMV);

  // Draw reference rhythm strip if overlay enabled
  if (showOverlay && refLeads?.II) {
    const refSignal = refLeads.II;
    const refPxPerSample = (w - 40) / refSignal.length;
    ctx.strokeStyle = 'rgba(0, 100, 200, 0.5)';
    ctx.lineWidth = 1.5;
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';
    ctx.beginPath();
    for (let j = 0; j < refSignal.length; j++) {
      const x = 20 + j * refPxPerSample;
      const yVal = rhythmY - refSignal[j] / uvPerPx;
      if (j === 0) ctx.moveTo(x, yVal);
      else ctx.lineTo(x, yVal);
    }
    ctx.stroke();
  }

  // Draw current rhythm strip
  if (leads.II) {
    const signal = leads.II;
    const pxPerSample = (w - 40) / signal.length;

    ctx.strokeStyle = '#1a1a1a';
    ctx.lineWidth = 1.3;
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';
    ctx.beginPath();

    for (let j = 0; j < signal.length; j++) {
      const x = 20 + j * pxPerSample;
      const yVal = rhythmY - signal[j] / uvPerPx;
      if (j === 0) ctx.moveTo(x, yVal);
      else ctx.lineTo(x, yVal);
    }
    ctx.stroke();
  }

  // Draw calipers (advanced system)
  drawAllCalipers(ctx, w, h);

  // Draw legend if overlay is active
  if (showOverlay) {
    ctx.font = '10px system-ui';
    ctx.fillStyle = 'rgba(0, 100, 200, 0.8)';
    ctx.fillText('Reference', w - 70, 15);
    ctx.fillStyle = '#1a1a1a';
    ctx.fillText('Current', w - 70, 28);
  }
}

function drawGrid(ctx, w, h, pxPerMm) {
  // Add subtle paper texture (thermal paper effect)
  addPaperTexture(ctx, w, h);

  // 1mm grid - subtle
  ctx.strokeStyle = 'rgba(185,55,55,0.20)';
  ctx.lineWidth = 0.6;
  for (let x = 0; x < w; x += pxPerMm) {
    ctx.beginPath();
    ctx.moveTo(x + 0.5, 0);
    ctx.lineTo(x + 0.5, h);
    ctx.stroke();
  }
  for (let y = 0; y < h; y += pxPerMm) {
    ctx.beginPath();
    ctx.moveTo(0, y + 0.5);
    ctx.lineTo(w, y + 0.5);
    ctx.stroke();
  }

  // 5mm grid - more prominent
  ctx.strokeStyle = 'rgba(175,45,45,0.50)';
  ctx.lineWidth = 1.2;
  for (let x = 0; x < w; x += pxPerMm * 5) {
    ctx.beginPath();
    ctx.moveTo(x + 0.5, 0);
    ctx.lineTo(x + 0.5, h);
    ctx.stroke();
  }
  for (let y = 0; y < h; y += pxPerMm * 5) {
    ctx.beginPath();
    ctx.moveTo(0, y + 0.5);
    ctx.lineTo(w, y + 0.5);
    ctx.stroke();
  }
}

// Add subtle paper texture to simulate thermal/ECG paper
function addPaperTexture(ctx, w, h) {
  const imageData = ctx.getImageData(0, 0, w, h);
  const data = imageData.data;

  // Very subtle noise - mimics paper grain
  for (let i = 0; i < data.length; i += 4) {
    const noise = (Math.random() - 0.5) * 6; // Very subtle
    data[i] = Math.max(0, Math.min(255, data[i] + noise));     // R
    data[i+1] = Math.max(0, Math.min(255, data[i+1] + noise)); // G
    data[i+2] = Math.max(0, Math.min(255, data[i+2] + noise)); // B
  }

  ctx.putImageData(imageData, 0, 0);
}

function drawFiducials(ctx, signal, fs, meas, y0, pxPerSample) {
  if (!meas.rPeaks) return;

  ctx.fillStyle = 'rgba(27,109,255,0.15)';
  ctx.strokeStyle = 'rgba(27,109,255,0.6)';

  meas.rPeaks.forEach(rIdx => {
    const x = 40 + rIdx * pxPerSample + panOffset;
    if (x < 0 || x > 2000) return;

    // R peak marker
    ctx.beginPath();
    ctx.arc(x, y0 - 20, 4, 0, Math.PI * 2);
    ctx.fill();
    ctx.stroke();
  });
}

// ============================================================================
// ADVANCED CALIPER SYSTEM
// ============================================================================

function getCaliperScaling() {
  // Use import settings for uploaded images, regular settings for synthetic ECGs
  const speed = imageMode
    ? parseInt(document.getElementById('importSpeed')?.value || 25)
    : parseInt(document.getElementById('speed').value);
  const gain = imageMode
    ? parseInt(document.getElementById('importGain')?.value || 10)
    : parseInt(document.getElementById('gain').value);
  const pxmm = parseInt(document.getElementById('pxmm').value);
  const fs = ecgData?.fs || 1000;

  const pxPerSample = (pxmm * speed) / fs;
  const uvPerPx = 1000 / (pxmm * gain);

  return { pxPerSample, uvPerPx, fs, pxmm, speed, gain };
}

function snapToRPeak(x, tolerance = 15) {
  if (!document.getElementById('snapPeaks').checked) return x;
  if (!measurements?.rPeaks || !ecgData) return x;

  const { pxPerSample } = getCaliperScaling();
  const baseX = 40 + panOffset;

  for (const rIdx of measurements.rPeaks) {
    const peakX = baseX + rIdx * pxPerSample;
    if (Math.abs(peakX - x) < tolerance) {
      return peakX;
    }
  }
  return x;
}

function snapToGrid(x, y) {
  if (!document.getElementById('snapGrid').checked) return { x, y };
  const { pxmm } = getCaliperScaling();
  const gridSize = pxmm * 5; // 5mm grid
  return {
    x: Math.round(x / gridSize) * gridSize,
    y: Math.round(y / gridSize) * gridSize
  };
}

function constrainPoint(x, y, refX, refY, shiftHeld) {
  if (!shiftHeld) return { x, y };

  const dx = Math.abs(x - refX);
  const dy = Math.abs(y - refY);

  // Constrain to horizontal or vertical based on dominant direction
  if (dx > dy) {
    return { x, y: refY }; // Horizontal constraint
  } else {
    return { x: refX, y }; // Vertical constraint
  }
}

function calculateMeasurement(p1, p2) {
  const { pxPerSample, uvPerPx, fs, pxmm, speed, gain } = getCaliperScaling();

  const dx = Math.abs(p2.x - p1.x);
  const dy = p1.y - p2.y; // Inverted because canvas Y is down

  let dt_ms, dv_uv;

  if (imageMode) {
    // For uploaded images: use calibrated pxPerMm if available, otherwise estimate
    const actualPxPerMm = (imageCalibration?.calibrated && imageCalibration?.pxPerMm)
      ? imageCalibration.pxPerMm
      : pxmm; // Fallback to display setting (less accurate)

    // Time: dx pixels â†’ mm â†’ seconds â†’ ms
    const dx_mm = dx / actualPxPerMm;
    dt_ms = (dx_mm / speed) * 1000;

    // Voltage: dy pixels â†’ mm â†’ mV â†’ ÂµV
    const dy_mm = Math.abs(dy) / actualPxPerMm;
    dv_uv = (dy_mm / gain) * 1000 * Math.sign(dy);
  } else {
    // For synthetic ECGs: use sample-based calculation
    dt_ms = dx / pxPerSample / fs * 1000;
    dv_uv = dy * uvPerPx;
  }

  const rate_bpm = dt_ms > 0 ? 60000 / dt_ms : 0;

  return { dt_ms, dv_uv, rate_bpm };
}

function drawAllCalipers(ctx, w, h) {
  const { pxPerSample, uvPerPx, fs } = getCaliperScaling();

  // Draw completed measurements
  caliperMeasurements.forEach((m, idx) => {
    const isSelected = m.id === selectedCaliperId;
    drawSingleCaliper(ctx, m.p1, m.p2, m.color, isSelected, m.id);
  });

  // Draw in-progress measurement
  if (activeCaliperPoint && lastMousePos) {
    let endPoint = { ...lastMousePos };

    // Apply constraints
    if (shiftHeld) {
      endPoint = constrainPoint(endPoint.x, endPoint.y, activeCaliperPoint.x, activeCaliperPoint.y, true);
    }

    // Apply snapping
    endPoint.x = snapToRPeak(endPoint.x);
    if (document.getElementById('snapGrid').checked) {
      const snapped = snapToGrid(endPoint.x, endPoint.y);
      endPoint = snapped;
    }

    const color = CALIPER_COLORS[nextCaliperColor % CALIPER_COLORS.length];
    drawSingleCaliper(ctx, activeCaliperPoint, endPoint, color, true, null, true);
  }
}

function drawSingleCaliper(ctx, p1, p2, color, isSelected, id, isPreview = false) {
  const { dt_ms, dv_uv, rate_bpm } = calculateMeasurement(p1, p2);

  const lineWidth = isSelected ? 2.5 : 1.5;
  const handleSize = isSelected ? 7 : 5;
  const alpha = isPreview ? 0.7 : 1;

  ctx.save();
  ctx.globalAlpha = alpha;

  // Vertical lines at endpoints
  ctx.strokeStyle = color;
  ctx.lineWidth = lineWidth;
  ctx.setLineDash(isPreview ? [4, 4] : []);

  ctx.beginPath();
  ctx.moveTo(p1.x, p1.y - 35);
  ctx.lineTo(p1.x, p1.y + 35);
  ctx.moveTo(p2.x, p2.y - 35);
  ctx.lineTo(p2.x, p2.y + 35);
  ctx.stroke();

  // Horizontal connecting line
  const midY = (p1.y + p2.y) / 2;
  ctx.beginPath();
  ctx.moveTo(p1.x, midY);
  ctx.lineTo(p2.x, midY);
  ctx.stroke();

  // Arrow heads
  const arrowSize = 6;
  const leftX = Math.min(p1.x, p2.x);
  const rightX = Math.max(p1.x, p2.x);

  ctx.fillStyle = color;
  ctx.beginPath();
  ctx.moveTo(leftX, midY);
  ctx.lineTo(leftX + arrowSize, midY - arrowSize/2);
  ctx.lineTo(leftX + arrowSize, midY + arrowSize/2);
  ctx.fill();

  ctx.beginPath();
  ctx.moveTo(rightX, midY);
  ctx.lineTo(rightX - arrowSize, midY - arrowSize/2);
  ctx.lineTo(rightX - arrowSize, midY + arrowSize/2);
  ctx.fill();

  // Draggable handles (squares at endpoints)
  if (isSelected && !isPreview) {
    ctx.fillStyle = color;
    ctx.fillRect(p1.x - handleSize, p1.y - handleSize, handleSize * 2, handleSize * 2);
    ctx.fillRect(p2.x - handleSize, p2.y - handleSize, handleSize * 2, handleSize * 2);

    // White centers
    ctx.fillStyle = '#fff';
    ctx.fillRect(p1.x - handleSize + 2, p1.y - handleSize + 2, handleSize * 2 - 4, handleSize * 2 - 4);
    ctx.fillRect(p2.x - handleSize + 2, p2.y - handleSize + 2, handleSize * 2 - 4, handleSize * 2 - 4);
  }

  // Measurement label background
  const midX = (p1.x + p2.x) / 2;
  const labelY = Math.min(p1.y, p2.y) - 45;

  const mainLabel = `${Math.round(dt_ms)} ms`;
  const rateLabel = dt_ms > 100 ? ` (${Math.round(rate_bpm)} bpm)` : '';
  const ampLabel = Math.abs(dv_uv) > 50 ? `  Î”V: ${Math.round(dv_uv)} ÂµV` : '';
  const fullLabel = mainLabel + rateLabel + ampLabel;

  ctx.font = 'bold 13px system-ui';
  const textWidth = ctx.measureText(fullLabel).width;

  // Background pill
  ctx.fillStyle = isSelected ? color : 'rgba(255,255,255,0.95)';
  ctx.beginPath();
  ctx.roundRect(midX - textWidth/2 - 8, labelY - 10, textWidth + 16, 22, 6);
  ctx.fill();

  if (!isSelected) {
    ctx.strokeStyle = color;
    ctx.lineWidth = 1;
    ctx.stroke();
  }

  // Label text
  ctx.fillStyle = isSelected ? '#fff' : color;
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText(fullLabel, midX, labelY);

  ctx.restore();
  ctx.setLineDash([]);
}

function hitTestCaliperHandle(x, y) {
  const handleSize = 10;

  for (const m of caliperMeasurements) {
    if (Math.abs(x - m.p1.x) < handleSize && Math.abs(y - m.p1.y) < handleSize) {
      return { measurementId: m.id, handle: 'p1' };
    }
    if (Math.abs(x - m.p2.x) < handleSize && Math.abs(y - m.p2.y) < handleSize) {
      return { measurementId: m.id, handle: 'p2' };
    }
  }
  return null;
}

function hitTestCaliper(x, y) {
  for (const m of caliperMeasurements) {
    const minX = Math.min(m.p1.x, m.p2.x) - 5;
    const maxX = Math.max(m.p1.x, m.p2.x) + 5;
    const minY = Math.min(m.p1.y, m.p2.y) - 40;
    const maxY = Math.max(m.p1.y, m.p2.y) + 40;

    if (x >= minX && x <= maxX && y >= minY && y <= maxY) {
      return m.id;
    }
  }
  return null;
}

function updateCaliperList() {
  const container = document.getElementById('caliperItems');
  const listPanel = document.getElementById('caliperList');

  if (caliperMeasurements.length === 0) {
    listPanel.style.display = 'none';
    return;
  }

  listPanel.style.display = 'block';

  container.innerHTML = caliperMeasurements.map((m, idx) => {
    const { dt_ms, dv_uv, rate_bpm } = calculateMeasurement(m.p1, m.p2);
    const isSelected = m.id === selectedCaliperId;

    return `
      <div class="caliper-item ${isSelected ? 'active' : ''}" onclick="selectCaliper('${m.id}')" data-id="${m.id}">
        <div class="caliper-item-color" style="background:${m.color}"></div>
        <div class="caliper-item-values">
          <span>
            <span class="caliper-item-value">${Math.round(dt_ms)}</span>
            <span class="caliper-item-label">ms</span>
          </span>
          ${dt_ms > 100 ? `<span>
            <span class="caliper-item-value">${Math.round(rate_bpm)}</span>
            <span class="caliper-item-label">bpm</span>
          </span>` : ''}
          ${Math.abs(dv_uv) > 50 ? `<span>
            <span class="caliper-item-value">${Math.round(dv_uv)}</span>
            <span class="caliper-item-label">ÂµV</span>
          </span>` : ''}
        </div>
        <button class="caliper-item-delete" onclick="event.stopPropagation(); deleteCaliper('${m.id}')" title="Delete">Ã—</button>
      </div>
    `;
  }).join('');
}

window.selectCaliper = function(id) {
  selectedCaliperId = id === selectedCaliperId ? null : id;
  updateCaliperList();
  redraw();
};

window.deleteCaliper = function(id) {
  caliperMeasurements = caliperMeasurements.filter(m => m.id !== id);
  if (selectedCaliperId === id) selectedCaliperId = null;
  updateCaliperList();
  redraw();
};

function updateCaliperStatus(text) {
  const statusEl = document.getElementById('caliperStatus');
  if (statusEl) {
    statusEl.querySelector('span:last-child').textContent = text;
  }
}

window.toggleCalipers = function() {
  calipersActive = !calipersActive;
  const btn = document.getElementById('calBtn');
  const statusEl = document.getElementById('caliperStatus');

  btn.textContent = calipersActive ? 'Calipers: ON' : 'Calipers: OFF';
  btn.classList.toggle('primary', !calipersActive);
  document.getElementById('c').style.cursor = calipersActive ? 'crosshair' : 'default';

  // Show/hide floating status indicator
  if (calipersActive) {
    statusEl.classList.add('active');
    updateCaliperStatus('Caliper Mode: Click and drag to measure');
    document.getElementById('caliperList').style.display = 'block';
  } else {
    statusEl.classList.remove('active');
  }
};

window.clearAllCalipers = function() {
  caliperMeasurements = [];
  activeCaliperPoint = null;
  selectedCaliperId = null;
  draggingHandle = null;
  updateCaliperList();
  redraw();
};

// Canvas mouse events
const canvas = document.getElementById('c');

canvas.addEventListener('mousedown', (e) => {
  const rect = canvas.getBoundingClientRect();
  const x = e.clientX - rect.left;
  const y = e.clientY - rect.top;

  // Handle calibration mode
  if (calibrationMode && imageMode) {
    handleCalibrationClick(x, y);
    return;
  }

  if (!calipersActive) return;

  // Check for handle drag
  const handle = hitTestCaliperHandle(x, y);
  if (handle && handle.measurementId === selectedCaliperId) {
    draggingHandle = handle;
    canvas.style.cursor = 'grabbing';
    return;
  }

  // Check for caliper selection
  const hitId = hitTestCaliper(x, y);
  if (hitId) {
    selectedCaliperId = hitId;
    updateCaliperList();
    redraw();
    return;
  }

  // Start new measurement
  let snappedX = snapToRPeak(x);
  if (document.getElementById('snapGrid').checked) {
    const snapped = snapToGrid(snappedX, y);
    snappedX = snapped.x;
  }

  if (!activeCaliperPoint) {
    activeCaliperPoint = { x: snappedX, y };
    selectedCaliperId = null;
    updateCaliperStatus('Drag to second point, then release');
  }
});

canvas.addEventListener('mousemove', (e) => {
  const rect = canvas.getBoundingClientRect();
  const x = e.clientX - rect.left;
  const y = e.clientY - rect.top;

  lastMousePos = { x, y };

  if (draggingHandle) {
    const m = caliperMeasurements.find(m => m.id === draggingHandle.measurementId);
    if (m) {
      let newX = snapToRPeak(x);
      let newY = y;

      // Apply shift constraint relative to the OTHER point
      const otherPoint = draggingHandle.handle === 'p1' ? m.p2 : m.p1;
      if (shiftHeld) {
        const constrained = constrainPoint(newX, newY, otherPoint.x, otherPoint.y, true);
        newX = constrained.x;
        newY = constrained.y;
      }

      if (draggingHandle.handle === 'p1') {
        m.p1 = { x: newX, y: newY };
      } else {
        m.p2 = { x: newX, y: newY };
      }
      updateCaliperList();
      redraw();
    }
    return;
  }

  if (activeCaliperPoint) {
    redraw();
  }

  // Update cursor based on hover
  if (calipersActive && !activeCaliperPoint) {
    const handle = hitTestCaliperHandle(x, y);
    if (handle && handle.measurementId === selectedCaliperId) {
      canvas.style.cursor = 'grab';
    } else {
      canvas.style.cursor = 'crosshair';
    }
  }
});

canvas.addEventListener('mouseup', (e) => {
  if (draggingHandle) {
    draggingHandle = null;
    canvas.style.cursor = calipersActive ? 'crosshair' : 'default';
    return;
  }

  if (!calipersActive || !activeCaliperPoint) return;

  const rect = canvas.getBoundingClientRect();
  let x = e.clientX - rect.left;
  let y = e.clientY - rect.top;

  // Apply constraints and snapping
  if (shiftHeld) {
    const constrained = constrainPoint(x, y, activeCaliperPoint.x, activeCaliperPoint.y, true);
    x = constrained.x;
    y = constrained.y;
  }

  x = snapToRPeak(x);
  if (document.getElementById('snapGrid').checked) {
    const snapped = snapToGrid(x, y);
    x = snapped.x;
    y = snapped.y;
  }

  // Only create measurement if there's meaningful distance
  const dist = Math.hypot(x - activeCaliperPoint.x, y - activeCaliperPoint.y);
  if (dist > 5) {
    const color = CALIPER_COLORS[nextCaliperColor % CALIPER_COLORS.length];
    nextCaliperColor++;

    const measurement = {
      id: 'cal_' + Date.now(),
      p1: activeCaliperPoint,
      p2: { x, y },
      color
    };

    caliperMeasurements.push(measurement);
    selectedCaliperId = measurement.id;
    updateCaliperList();

    // Show success feedback briefly
    const { dt_ms } = calculateMeasurement(measurement.p1, measurement.p2);
    updateCaliperStatus(`Measured: ${Math.round(dt_ms)} ms â€” Click and drag to add more`);
  } else {
    updateCaliperStatus('Caliper Mode: Click and drag to measure');
  }

  activeCaliperPoint = null;
  redraw();
});

canvas.addEventListener('mouseleave', () => {
  if (draggingHandle) {
    draggingHandle = null;
  }
  lastMousePos = null;
  if (activeCaliperPoint) {
    redraw();
  }
});

// Keyboard shortcuts
document.addEventListener('keydown', (e) => {
  if (e.key === 'Shift') {
    shiftHeld = true;
  }

  if (document.activeElement.tagName === 'INPUT' || document.activeElement.tagName === 'SELECT') {
    return;
  }

  if (e.key === 'c' || e.key === 'C') {
    toggleCalipers();
  }

  if (e.key === 'Escape') {
    activeCaliperPoint = null;
    selectedCaliperId = null;
    updateCaliperList();
    if (calipersActive) {
      updateCaliperStatus('Caliper Mode: Click and drag to measure');
    }
    redraw();
  }

  if ((e.key === 'Delete' || e.key === 'Backspace') && selectedCaliperId) {
    deleteCaliper(selectedCaliperId);
  }
});

document.addEventListener('keyup', (e) => {
  if (e.key === 'Shift') {
    shiftHeld = false;
  }
});

// Touch event support for trackpad and touch devices
let touchStartPoint = null;

canvas.addEventListener('touchstart', (e) => {
  if (!calipersActive || e.touches.length !== 1) return;
  e.preventDefault();

  const touch = e.touches[0];
  const rect = canvas.getBoundingClientRect();
  const x = touch.clientX - rect.left;
  const y = touch.clientY - rect.top;

  // Check for caliper selection first
  const hitId = hitTestCaliper(x, y);
  if (hitId) {
    selectedCaliperId = hitId;
    updateCaliperList();
    redraw();
    return;
  }

  let snappedX = snapToRPeak(x);
  touchStartPoint = { x: snappedX, y };
  activeCaliperPoint = touchStartPoint;
  updateCaliperStatus('Drag to second point, then lift finger');
}, { passive: false });

canvas.addEventListener('touchmove', (e) => {
  if (!calipersActive || !touchStartPoint || e.touches.length !== 1) return;
  e.preventDefault();

  const touch = e.touches[0];
  const rect = canvas.getBoundingClientRect();
  lastMousePos = { x: touch.clientX - rect.left, y: touch.clientY - rect.top };
  redraw();
}, { passive: false });

canvas.addEventListener('touchend', (e) => {
  if (!calipersActive || !touchStartPoint) return;
  e.preventDefault();

  const touch = e.changedTouches[0];
  const rect = canvas.getBoundingClientRect();
  let x = touch.clientX - rect.left;
  let y = touch.clientY - rect.top;

  x = snapToRPeak(x);

  const dist = Math.hypot(x - touchStartPoint.x, y - touchStartPoint.y);
  if (dist > 20) {  // Slightly more forgiving threshold for touch
    const color = CALIPER_COLORS[nextCaliperColor % CALIPER_COLORS.length];
    nextCaliperColor++;

    const measurement = {
      id: 'cal_' + Date.now(),
      p1: touchStartPoint,
      p2: { x, y },
      color
    };

    caliperMeasurements.push(measurement);
    selectedCaliperId = measurement.id;
    updateCaliperList();

    const { dt_ms } = calculateMeasurement(measurement.p1, measurement.p2);
    updateCaliperStatus(`Measured: ${Math.round(dt_ms)} ms â€” Tap and drag to add more`);
  } else {
    updateCaliperStatus('Caliper Mode: Tap and drag to measure');
  }

  touchStartPoint = null;
  activeCaliperPoint = null;
  lastMousePos = null;
  redraw();
}, { passive: false });

// ============================================================================
// EXPORT FUNCTIONS
// ============================================================================

window.printWorksheet = function() {
  setMode('quiz');
  setTimeout(() => window.print(), 100);
};

window.printAnswerKey = function() {
  setMode('teach');
  setTimeout(() => window.print(), 100);
};

window.exportPNG = function() {
  const canvas = document.getElementById('c');
  const link = document.createElement('a');
  link.download = 'ecg-export.png';
  link.href = canvas.toDataURL('image/png');
  link.click();
};

window.exportJSON = function() {
  if (!ecgData && !imageMode) {
    showStatus('Generate or load an ECG first', 'error');
    return;
  }

  let exportData;

  if (imageMode && uploadedImage) {
    // Export teaching case with image
    const canvas = document.createElement('canvas');
    canvas.width = uploadedImage.width;
    canvas.height = uploadedImage.height;
    canvas.getContext('2d').drawImage(uploadedImage, 0, 0);

    exportData = {
      type: 'teaching_case',
      version: '1.0',
      source: {
        type: 'uploaded_image',
        filename: uploadedImageName,
        imageData: canvas.toDataURL('image/png'),
        width: uploadedImage.width,
        height: uploadedImage.height
      },
      calibration: {
        paperSpeed_mm_s: parseInt(document.getElementById('importSpeed')?.value || 25),
        gain_mm_mV: parseInt(document.getElementById('importGain')?.value || 10),
        scale_pxmm: parseInt(document.getElementById('pxmm')?.value || 4),
        pxPerMm: imageCalibration?.pxPerMm || null,
        calibrated: imageCalibration?.calibrated || false
      },
      measurements: caliperMeasurements.map(m => {
        const { dt_ms, dv_uv, rate_bpm } = calculateMeasurement(m.p1, m.p2);
        return {
          id: m.id,
          color: m.color,
          p1: m.p1,
          p2: m.p2,
          dt_ms: Math.round(dt_ms),
          dv_uv: Math.round(dv_uv),
          rate_bpm: Math.round(rate_bpm)
        };
      }),
      exportedAt: new Date().toISOString()
    };
  } else {
    // Export synthetic ECG
    exportData = ecgData;
  }

  const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
  const link = document.createElement('a');
  link.download = imageMode ? 'teaching-case.json' : 'ecg-export.json';
  link.href = URL.createObjectURL(blob);
  link.click();
  showStatus(imageMode ? 'Teaching case exported with measurements' : 'JSON exported', 'success', 2000);
};

window.exportCSV = function() {
  if (!ecgData) {
    showStatus('Generate or load an ECG first', 'error');
    return;
  }

  const leads = ecgData.leads_uV;
  const leadNames = Object.keys(leads);
  const len = leads[leadNames[0]].length;

  let csv = 'sample,' + leadNames.join(',') + '\n';
  for (let i = 0; i < len; i++) {
    csv += i + ',' + leadNames.map(l => leads[l][i]).join(',') + '\n';
  }

  const blob = new Blob([csv], { type: 'text/csv' });
  const link = document.createElement('a');
  link.download = 'ecg-export.csv';
  link.href = URL.createObjectURL(blob);
  link.click();
  showStatus('CSV exported', 'success', 2000);
};

// ============================================================================
// INITIALIZATION
// ============================================================================

window.redraw = redraw;

// Resize handling
window.addEventListener('resize', redraw);

// Initial draw
redraw();

// Check for URL parameters (from bookmarklet or direct link)
const urlParams = new URLSearchParams(window.location.search);
const imgParam = urlParams.get('img');

if (imgParam) {
  // Load image from URL parameter
  showStatus('Loading ECG from URL...', 'info', 0);
  loadImageFromURL(decodeURIComponent(imgParam));
} else {
  // Generate initial case
  generate();
}

</script>

<!-- Generate from Image Modal -->
<div id="generateModal" class="modal-overlay" onclick="closeGenerateModal(event)">
  <div class="modal-content" onclick="event.stopPropagation()">
    <div class="modal-header">
      <h2>Generate Matching ECG</h2>
      <button class="modal-close" onclick="closeGenerateModal()">&times;</button>
    </div>

    <div class="modal-preview">
      <img id="modalPreviewImg" src="" alt="Uploaded ECG">
      <div class="modal-preview-label">Reference image (for visual comparison)</div>
    </div>

    <div class="modal-form">
      <label>
        What diagnosis do you see?
        <select id="modalDx">
          <optgroup label="Normal">
            <option value="Normal sinus">Normal sinus rhythm</option>
            <option value="Sinus bradycardia">Sinus bradycardia</option>
            <option value="Sinus tachycardia">Sinus tachycardia</option>
          </optgroup>
          <optgroup label="Conduction">
            <option value="RBBB">Right bundle branch block (RBBB)</option>
            <option value="LBBB">Left bundle branch block (LBBB)</option>
            <option value="LAFB">Left anterior fascicular block</option>
            <option value="1st degree AVB">1st degree AV block</option>
            <option value="2nd degree AVB (Wenckebach)">2nd degree AVB (Wenckebach)</option>
            <option value="2nd degree AVB (Mobitz II)">2nd degree AVB (Mobitz II)</option>
            <option value="3rd degree AVB">3rd degree (complete) heart block</option>
          </optgroup>
          <optgroup label="Pre-excitation">
            <option value="WPW">Wolff-Parkinson-White (WPW)</option>
          </optgroup>
          <optgroup label="Hypertrophy">
            <option value="LVH">Left ventricular hypertrophy (LVH)</option>
            <option value="RVH">Right ventricular hypertrophy (RVH)</option>
          </optgroup>
          <optgroup label="Tachyarrhythmias">
            <option value="SVT (narrow)">SVT (narrow complex)</option>
            <option value="Atrial flutter (2:1)">Atrial flutter (2:1)</option>
            <option value="Atrial fibrillation">Atrial fibrillation</option>
          </optgroup>
          <optgroup label="Ischemia">
            <option value="STEMI (anterior)">STEMI (anterior)</option>
          </optgroup>
          <optgroup label="Repolarization">
            <option value="Long QT">Long QT syndrome</option>
            <option value="Pericarditis">Pericarditis</option>
            <option value="Brugada (Type 1)">Brugada syndrome (Type 1)</option>
          </optgroup>
          <optgroup label="Metabolic">
            <option value="Hyperkalemia">Hyperkalemia</option>
          </optgroup>
          <optgroup label="Ectopy">
            <option value="PACs">Premature atrial contractions (PACs)</option>
            <option value="PVCs">Premature ventricular contractions (PVCs)</option>
          </optgroup>
        </select>
      </label>

      <label>
        Estimated patient age
        <div class="modal-range-row">
          <input type="range" id="modalAge" min="0" max="99" value="45" oninput="updateModalAgeDisplay()">
          <span class="modal-range-value" id="modalAgeValue">45 yrs</span>
        </div>
        <div class="modal-hr-estimate" id="modalHREstimate">Expected HR: ~70 bpm</div>
      </label>

      <div class="modal-actions">
        <button class="btn-secondary" onclick="closeGenerateModal()">Cancel</button>
        <button class="btn-primary" onclick="digitizeFromModal()" id="digitizeBtn">Digitize ECG</button>
        <button class="btn-secondary" onclick="generateFromModal()">Generate Synthetic</button>
      </div>

      <div class="modal-tip" id="modalTip">
        <strong>Digitize:</strong> Extract the actual waveform from your image (recommended)<br>
        <strong>Generate:</strong> Create a synthetic ECG with the same diagnosis pattern
      </div>
    </div>
  </div>
</div>

</body>
</html>
