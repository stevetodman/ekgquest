<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>EKGQuest Lab â€” Teaching ECG Laboratory</title>
<style>
  :root {
    --paper: #fef9f5;
    --paper-dark: #fdf5ee;
    --trace: #1a1a1a;
    --grid1: rgba(190,50,50,0.22);
    --grid5: rgba(180,40,40,0.52);
    --text: #141414;
    --muted: #5c5c5c;
    --panel: #ffffff;
    --border: #e2d6d6;
    --btn: #f7f0f0;
    --btn2: #efe3e3;
    --accent: #1b6dff;
    --ok: #0a7a3b;
    --warn: #b00020;
    --chip: #faf6f6;
    --quiz-bg: #fff8e6;
    --quiz-border: #f0d88c;
    --teach-bg: #e8f4ff;
    --teach-border: #a0c8f0;
  }

  /* Clinical ECG font stack - prefer monospace for measurements */
  @font-face {
    font-family: 'ECG';
    src: local('Courier New'), local('Consolas'), local('Liberation Mono');
  }

  * { box-sizing: border-box; }
  body {
    background: #f3f3f3;
    color: var(--text);
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    margin: 0;
    padding: 16px;
  }

  /* Clinical monospace for ECG labels and measurements */
  .ecg-label, .metric-value, #caseInfo {
    font-family: 'Courier New', Consolas, 'Liberation Mono', monospace;
    letter-spacing: -0.5px;
  }

  /* Header */
  .header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 16px;
    margin-bottom: 12px;
    flex-wrap: wrap;
  }
  .header h1 {
    margin: 0;
    font-size: 22px;
    font-weight: 700;
    letter-spacing: -0.3px;
  }
  .header-badge {
    padding: 4px 10px;
    border-radius: 999px;
    font-size: 11px;
    font-weight: 600;
    letter-spacing: 0.3px;
  }
  .badge-synth { background: #ffe4e8; border: 1px solid #f0b6c0; color: #b00020; }
  .badge-real { background: #e5f7ec; border: 1px solid #b5e1c7; color: #0b6b3b; }
  .header-info {
    font-size: 12px;
    color: var(--muted);
    display: flex;
    flex-direction: column;
    gap: 4px;
  }

  /* Status messages */
  .status-msg {
    font-size: 11px;
    padding: 4px 8px;
    border-radius: 4px;
    display: none;
  }
  .status-msg.visible { display: inline-block; }
  .status-msg.error {
    background: #fee2e2;
    color: #b91c1c;
    border: 1px solid #fecaca;
  }
  .status-msg.success {
    background: #dcfce7;
    color: #166534;
    border: 1px solid #bbf7d0;
  }
  .status-msg.info {
    background: #dbeafe;
    color: #1e40af;
    border: 1px solid #bfdbfe;
  }

  /* Mode Toggle */
  .mode-toggle {
    display: flex;
    gap: 0;
    background: var(--panel);
    border: 2px solid var(--border);
    border-radius: 12px;
    padding: 4px;
    box-shadow: 0 2px 8px rgba(0,0,0,0.06);
  }
  .mode-btn {
    padding: 10px 24px;
    border: none;
    border-radius: 8px;
    font-size: 14px;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.15s;
    background: transparent;
    color: var(--muted);
  }
  .mode-btn:hover { background: var(--btn); }
  .mode-btn.active-quiz {
    background: var(--quiz-bg);
    color: #8a5a00;
    box-shadow: 0 2px 4px rgba(0,0,0,0.08);
  }
  .mode-btn.active-teach {
    background: var(--teach-bg);
    color: #1b5a8a;
    box-shadow: 0 2px 4px rgba(0,0,0,0.08);
  }

  /* Reveal Button */
  .reveal-btn {
    display: none;
    padding: 10px 28px;
    background: linear-gradient(135deg, #ff9500, #ff6b00);
    color: white;
    border: none;
    border-radius: 10px;
    font-size: 15px;
    font-weight: 700;
    cursor: pointer;
    box-shadow: 0 3px 12px rgba(255,107,0,0.3);
    transition: all 0.15s;
  }
  .reveal-btn:hover {
    transform: translateY(-1px);
    box-shadow: 0 4px 16px rgba(255,107,0,0.4);
  }
  .reveal-btn.visible { display: block; }

  /* Tabs */
  .tabs {
    display: flex;
    gap: 4px;
    background: var(--panel);
    border: 1px solid var(--border);
    border-radius: 12px 12px 0 0;
    padding: 8px 8px 0 8px;
    margin-top: 12px;
  }
  .tab {
    padding: 10px 20px;
    border: none;
    border-radius: 8px 8px 0 0;
    font-size: 13px;
    font-weight: 600;
    cursor: pointer;
    background: transparent;
    color: var(--muted);
    border-bottom: 2px solid transparent;
    margin-bottom: -1px;
  }
  .tab:hover { background: var(--btn); }
  .tab.active {
    background: var(--paper);
    color: var(--text);
    border-bottom: 2px solid var(--paper);
  }

  /* Tab Panels */
  .tab-panels {
    background: var(--panel);
    border: 1px solid var(--border);
    border-top: none;
    border-radius: 0 0 12px 12px;
    padding: 12px;
  }
  .tab-panel {
    display: none;
    gap: 12px;
    flex-wrap: wrap;
    align-items: center;
  }
  .tab-panel.active { display: flex; }

  /* Form Controls */
  label {
    display: flex;
    gap: 8px;
    align-items: center;
    color: var(--muted);
    font-size: 13px;
  }
  select, input[type="number"], input[type="file"] {
    background: #fff;
    color: var(--text);
    border: 1px solid var(--border);
    border-radius: 8px;
    padding: 6px 10px;
    font-size: 13px;
  }
  input[type="number"] { width: 80px; }
  input[type="checkbox"] { width: 16px; height: 16px; }
  button {
    background: var(--btn);
    color: var(--text);
    border: 1px solid var(--border);
    border-radius: 10px;
    padding: 8px 14px;
    font-size: 13px;
    cursor: pointer;
    font-weight: 500;
  }
  button:hover { background: var(--btn2); }
  button.primary {
    background: var(--accent);
    color: white;
    border-color: var(--accent);
  }
  button.primary:hover { background: #1558cc; }

  .hint { color: var(--muted); font-size: 12px; }
  .divider { width: 1px; height: 28px; background: var(--border); margin: 0 4px; }

  /* Measurements Panel */
  .measurements {
    background: var(--panel);
    border: 1px solid var(--border);
    border-radius: 12px;
    padding: 12px;
    margin-top: 12px;
    transition: opacity 0.2s, max-height 0.3s;
  }
  .measurements.hidden {
    opacity: 0.3;
    max-height: 60px;
    overflow: hidden;
    position: relative;
  }
  .measurements.hidden::after {
    content: "Measurements hidden in Quiz mode";
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: var(--quiz-bg);
    border: 1px solid var(--quiz-border);
    padding: 8px 16px;
    border-radius: 8px;
    font-size: 13px;
    font-weight: 600;
    color: #8a5a00;
  }
  .measurements-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(160px, 1fr));
    gap: 8px;
  }
  .metric {
    background: #fff;
    border: 1px solid var(--border);
    border-radius: 10px;
    padding: 10px;
  }
  .metric-label {
    font-size: 11px;
    color: var(--muted);
    margin-bottom: 4px;
  }
  .metric-value {
    font-size: 14px;
    font-weight: 650;
    color: var(--text);
  }
  .metric-value small { font-weight: 500; color: var(--muted); }
  .ok { color: var(--ok); }
  .bad { color: var(--warn); }

  /* ECG Canvas */
  .canvas-wrap {
    border: 1px solid var(--border);
    border-radius: 14px;
    overflow: hidden;
    background: var(--paper);
    margin-top: 12px;
  }
  canvas {
    display: block;
    width: 100%;
    height: 800px;
    background: var(--paper);
  }

  /* Footer */
  .footer {
    margin-top: 12px;
    padding: 10px;
    color: var(--muted);
    font-size: 12px;
    text-align: center;
  }
  .kbd {
    font-family: ui-monospace, Menlo, Consolas, monospace;
    background: #fff;
    border: 1px solid var(--border);
    border-radius: 5px;
    padding: 2px 6px;
    font-size: 11px;
  }

  /* Caliper Measurement List */
  .caliper-list {
    background: var(--panel);
    border: 1px solid var(--border);
    border-radius: 12px;
    padding: 12px;
    margin-top: 12px;
  }
  .caliper-list-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 8px;
  }
  .caliper-list-title {
    font-size: 13px;
    font-weight: 600;
    color: var(--text);
  }
  .caliper-items {
    display: flex;
    flex-direction: column;
    gap: 6px;
  }
  .caliper-item {
    display: flex;
    align-items: center;
    gap: 10px;
    padding: 8px 10px;
    background: #fff;
    border: 1px solid var(--border);
    border-radius: 8px;
    font-size: 13px;
  }
  .caliper-item.active {
    border-color: var(--accent);
    background: #f0f7ff;
  }
  .caliper-item-color {
    width: 12px;
    height: 12px;
    border-radius: 3px;
  }
  .caliper-item-values {
    flex: 1;
    display: flex;
    gap: 16px;
  }
  .caliper-item-value {
    font-family: ui-monospace, Menlo, Consolas, monospace;
    font-weight: 600;
  }
  .caliper-item-label {
    color: var(--muted);
    font-size: 11px;
    margin-left: 2px;
  }
  .caliper-item-delete {
    background: none;
    border: none;
    color: var(--muted);
    cursor: pointer;
    padding: 4px;
    border-radius: 4px;
    font-size: 16px;
    line-height: 1;
  }
  .caliper-item-delete:hover {
    background: #fee;
    color: var(--warn);
  }
  .caliper-empty {
    color: var(--muted);
    font-size: 12px;
    text-align: center;
    padding: 12px;
  }
  .caliper-handle {
    cursor: grab;
  }
  .caliper-handle:active {
    cursor: grabbing;
  }

  /* Caliper floating status */
  .caliper-status {
    position: fixed;
    bottom: 20px;
    left: 50%;
    transform: translateX(-50%);
    background: rgba(0, 0, 0, 0.85);
    color: white;
    padding: 10px 20px;
    border-radius: 24px;
    font-size: 13px;
    font-weight: 500;
    display: none;
    align-items: center;
    gap: 10px;
    z-index: 1000;
    box-shadow: 0 4px 20px rgba(0,0,0,0.3);
    animation: slideUp 0.2s ease-out;
  }
  .caliper-status.active { display: flex; }
  .caliper-status .dot {
    width: 8px;
    height: 8px;
    background: #4caf50;
    border-radius: 50%;
    animation: pulse 1.5s infinite;
  }
  @keyframes slideUp {
    from { opacity: 0; transform: translateX(-50%) translateY(10px); }
    to { opacity: 1; transform: translateX(-50%) translateY(0); }
  }
  @keyframes pulse {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.4; }
  }

  /* Focus styles for accessibility */
  button:focus-visible, select:focus-visible, input:focus-visible, .tab:focus-visible {
    outline: 2px solid var(--accent);
    outline-offset: 2px;
  }

  /* Skip link for keyboard users */
  .skip-link {
    position: absolute;
    top: -40px;
    left: 0;
    background: var(--accent);
    color: white;
    padding: 8px 16px;
    z-index: 100;
    border-radius: 0 0 8px 0;
  }
  .skip-link:focus { top: 0; }

  /* Advanced Section */
  .advanced-toggle {
    display: flex;
    align-items: center;
    gap: 6px;
    color: var(--muted);
    font-size: 12px;
    cursor: pointer;
    padding: 6px 10px;
    border-radius: 8px;
    background: transparent;
    border: 1px solid transparent;
  }
  .advanced-toggle:hover { background: var(--btn); }
  .advanced-toggle:focus-visible {
    outline: 2px solid var(--accent);
    outline-offset: 2px;
  }
  .advanced-content {
    display: none;
    flex-wrap: wrap;
    gap: 12px;
    padding-top: 10px;
    border-top: 1px solid var(--border);
    margin-top: 10px;
  }
  .advanced-content.open { display: flex; }

  /* Print Styles */
  @media print {
    body { margin: 0; padding: 0; background: white; }
    .header, .tabs, .tab-panels, .mode-toggle, .reveal-btn, .footer { display: none !important; }
    .measurements.hidden { opacity: 1; max-height: none; overflow: visible; }
    .measurements.hidden::after { display: none; }
    .canvas-wrap { border: none; border-radius: 0; }
    canvas { height: auto; }
  }

  /* Mobile - Tablet */
  @media (max-width: 768px) {
    body { padding: 8px; }
    .header h1 { font-size: 1.3rem; }
    .tabs { flex-wrap: wrap; gap: 4px; }
    .tab-btn { padding: 8px 12px; font-size: 0.85rem; }
    .tab-panel { padding: 12px; }
    .tab-panel label { flex-direction: column; align-items: flex-start; gap: 4px; }
    .tab-panel input, .tab-panel select { width: 100%; max-width: none; }
    .measurements-grid { grid-template-columns: repeat(2, 1fr); gap: 8px; }
    canvas { height: 500px; min-height: 400px; }
    .mode-btn { padding: 8px 16px; font-size: 13px; }
    .canvas-wrap { border-radius: 8px; }
    .reveal-btn { padding: 10px 20px; font-size: 0.9rem; }
  }

  /* Mobile - Phone */
  @media (max-width: 480px) {
    body { padding: 4px; }
    .header { padding: 12px; margin-bottom: 12px; }
    .header h1 { font-size: 1.1rem; }
    .mode-toggle { margin-bottom: 8px; }
    .mode-btn { padding: 6px 12px; font-size: 12px; }
    .tabs { gap: 2px; padding: 0 8px; }
    .tab-btn { padding: 6px 10px; font-size: 0.8rem; flex: 1; text-align: center; }
    .tab-panel { padding: 8px; }
    .tab-panel label { font-size: 0.85rem; margin-bottom: 8px; }
    .measurements-grid { grid-template-columns: 1fr 1fr; gap: 6px; }
    .measurements-grid > div { padding: 6px 8px; font-size: 0.8rem; }
    canvas { height: 400px; min-height: 300px; }
    .reveal-btn { padding: 8px 16px; font-size: 0.85rem; width: 100%; }
    .footer { padding: 12px; font-size: 0.75rem; }
    .caliper-status { font-size: 0.8rem; padding: 6px 10px; }
  }

  /* Touch-friendly controls */
  @media (hover: none) and (pointer: coarse) {
    .tab-btn, .mode-btn, button, select, input {
      min-height: 44px;
      min-width: 44px;
    }
    .tab-panel label {
      padding: 4px 0;
    }
    .reveal-btn {
      min-height: 48px;
    }
  }

  /* Drag and drop overlay */
  body.drag-active::after {
    content: 'Drop ECG image here';
    position: fixed;
    inset: 0;
    background: rgba(0, 100, 200, 0.9);
    color: white;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 2rem;
    font-weight: bold;
    z-index: 10000;
    pointer-events: none;
    border: 4px dashed white;
    margin: 20px;
    border-radius: 20px;
  }
</style>
</head>
<body>

<!-- Skip link for keyboard navigation -->
<a href="#ecgCanvas" class="skip-link">Skip to ECG</a>

<!-- Header -->
<header class="header" role="banner">
  <div style="display:flex; align-items:center; gap:12px">
    <h1>EKGQuest Lab</h1>
    <span class="header-badge badge-synth" id="sourceBadge" role="status" aria-live="polite">SYNTHETIC</span>
  </div>

  <div class="mode-toggle" role="group" aria-label="Display mode">
    <button class="mode-btn active-quiz" id="quizModeBtn" onclick="setMode('quiz')" aria-pressed="true">Quiz Mode</button>
    <button class="mode-btn" id="teachModeBtn" onclick="setMode('teach')" aria-pressed="false">Teach Mode</button>
  </div>

  <button class="reveal-btn" id="revealBtn" onclick="reveal()" aria-label="Reveal diagnosis and measurements">Reveal Answers</button>

  <div class="header-info">
    <span id="caseInfo">No case loaded</span>
    <span id="statusMsg" class="status-msg" role="status" aria-live="polite"></span>
  </div>
</header>

<!-- Tabs -->
<div class="tabs">
  <button class="tab active" onclick="showTab('case')">Case</button>
  <button class="tab" onclick="showTab('view')">View</button>
  <button class="tab" onclick="showTab('tools')">Tools</button>
  <button class="tab" onclick="showTab('compare')">Compare</button>
  <button class="tab" onclick="showTab('export')">Export</button>
</div>

<!-- Tab Panels -->
<div class="tab-panels">
  <!-- Case Panel -->
  <div class="tab-panel active" id="panel-case">
    <label>Age (years)
      <input id="ageYears" type="number" min="0" max="100" step="0.1" value="45">
    </label>
    <label>Sex
      <select id="sex">
        <option value="">Any</option>
        <option value="male">Male</option>
        <option value="female">Female</option>
      </select>
    </label>
    <label>Diagnosis
      <select id="dx">
        <optgroup label="Normal">
          <option>Normal sinus</option>
          <option>Sinus bradycardia</option>
          <option>Sinus tachycardia</option>
        </optgroup>
        <optgroup label="Conduction">
          <option>RBBB</option>
          <option>LBBB</option>
          <option>LAFB</option>
          <option>1st degree AVB</option>
          <option>2nd degree AVB (Wenckebach)</option>
          <option>2nd degree AVB (Mobitz II)</option>
          <option>3rd degree AVB</option>
        </optgroup>
        <optgroup label="Pre-excitation">
          <option>WPW</option>
        </optgroup>
        <optgroup label="Hypertrophy">
          <option>LVH</option>
          <option>RVH</option>
        </optgroup>
        <optgroup label="Tachyarrhythmias">
          <option>SVT (narrow)</option>
          <option>Atrial flutter (2:1)</option>
          <option>Atrial fibrillation</option>
        </optgroup>
        <optgroup label="Ischemia">
          <option>STEMI (anterior)</option>
        </optgroup>
        <optgroup label="Repolarization">
          <option>Long QT</option>
          <option>Pericarditis</option>
          <option>Brugada (Type 1)</option>
        </optgroup>
        <optgroup label="Metabolic">
          <option>Hyperkalemia</option>
        </optgroup>
        <optgroup label="Ectopy">
          <option>PACs</option>
          <option>PVCs</option>
        </optgroup>
      </select>
    </label>
    <label>Seed
      <input id="seed" type="number" min="1" step="1" value="7">
    </label>
    <button class="primary" id="genBtn" onclick="generate()">Generate</button>
    <button id="randBtn" onclick="randomize()">Random</button>
    <div class="divider"></div>
    <label>Load JSON/CSV
      <input type="file" id="fileInput" accept=".json,.csv">
    </label>
    <div class="divider"></div>
    <div class="upload-section">
      <strong style="font-size:12px;color:var(--muted)">Import Real ECG</strong>
      <button id="clipboardBtn" onclick="loadFromClipboard()" title="Copy any ECG image, then click this">
        ðŸ“‹ Paste from Clipboard
      </button>
      <label>Upload PDF or Image
        <input type="file" id="imageInput" accept=".pdf,.png,.jpg,.jpeg,.webp">
      </label>
      <div id="calibrationControls" style="display:none">
        <label>Paper speed
          <select id="importSpeed" onchange="redraw()">
            <option value="25" selected>25 mm/s</option>
            <option value="50">50 mm/s</option>
          </select>
        </label>
        <label>Gain
          <select id="importGain" onchange="redraw()">
            <option value="10" selected>10 mm/mV</option>
            <option value="5">5 mm/mV</option>
            <option value="20">20 mm/mV</option>
          </select>
        </label>
        <button id="calibrateBtn" onclick="startCalibration()">Calibrate Grid</button>
        <button id="digitizeBtn" onclick="digitizeECG()" class="primary">Digitize Trace</button>
        <button onclick="clearUploadedImage()">Clear</button>
        <div id="calibrationStatus" class="hint" style="display:none"></div>
      </div>
    </div>
  </div>

  <!-- View Panel -->
  <div class="tab-panel" id="panel-view">
    <label>Layout
      <select id="layout" onchange="redraw()">
        <option value="stacked" selected>Stacked (15 leads)</option>
        <option value="print12">12-lead print + rhythm</option>
      </select>
    </label>
    <label>Speed
      <select id="speed" onchange="redraw()">
        <option value="25" selected>25 mm/s</option>
        <option value="50">50 mm/s</option>
      </select>
    </label>
    <label>Gain
      <select id="gain" onchange="redraw()">
        <option value="5">5 mm/mV</option>
        <option value="10" selected>10 mm/mV</option>
        <option value="20">20 mm/mV</option>
      </select>
    </label>
    <label>Scale
      <select id="pxmm" onchange="redraw()">
        <option value="4" selected>Fit</option>
        <option value="6">Medium</option>
        <option value="8">Large</option>
      </select>
    </label>
    <div class="divider"></div>
    <button type="button" class="advanced-toggle" onclick="toggleAdvanced()" aria-expanded="false" aria-controls="advancedContent">
      <span id="advIcon" aria-hidden="true">+</span> Advanced
    </button>
    <div class="advanced-content" id="advancedContent">
      <label><input id="noise" type="checkbox" checked onchange="generate()"> Noise</label>
      <label><input id="filters" type="checkbox" checked onchange="generate()"> Diagnostic filter</label>
      <label><input id="fid" type="checkbox" checked onchange="redraw()"> Fiducials</label>
      <label><input id="snap" type="checkbox" checked> Snap calipers</label>
      <label><input id="median" type="checkbox" checked onchange="redraw()"> Median-beat</label>
    </div>
  </div>

  <!-- Tools Panel -->
  <div class="tab-panel" id="panel-tools">
    <button id="calBtn" class="primary" onclick="toggleCalipers()">Calipers: OFF</button>
    <label><input id="snapPeaks" type="checkbox" checked> Snap to R-peaks</label>
    <label><input id="snapGrid" type="checkbox"> Snap to grid</label>
    <button onclick="clearAllCalipers()">Clear All</button>
    <div class="divider"></div>
    <div class="caliper-instructions">
      <strong>How to measure:</strong>
      <ol style="margin:4px 0 0 16px;padding:0;font-size:12px;color:var(--muted)">
        <li>Click and drag across the waveform</li>
        <li>Release to create measurement</li>
        <li>Click measurement to select, drag handles to adjust</li>
      </ol>
    </div>
    <div class="divider"></div>
    <span class="hint">
      <span class="kbd">C</span> Toggle &nbsp;
      <span class="kbd">Shift</span> Lock H/V &nbsp;
      <span class="kbd">Del</span> Delete &nbsp;
      <span class="kbd">Esc</span> Cancel
    </span>
  </div>

  <!-- Compare Panel -->
  <div class="tab-panel" id="panel-compare">
    <button id="storeRefBtn" class="primary" onclick="storeReference()">Store as Reference</button>
    <button id="clearRefBtn" onclick="clearReference()" disabled>Clear Reference</button>
    <div class="divider"></div>
    <label><input id="showOverlay" type="checkbox" onchange="redraw()" disabled> Show overlay</label>
    <label><input id="showDiff" type="checkbox" onchange="redraw()"> Highlight differences</label>
    <div class="divider"></div>
    <div id="refInfo" class="hint">No reference stored</div>
  </div>

  <!-- Export Panel -->
  <div class="tab-panel" id="panel-export">
    <button onclick="printWorksheet()">Print Worksheet</button>
    <button onclick="printAnswerKey()">Print Answer Key</button>
    <div class="divider"></div>
    <button onclick="exportPNG()">Export PNG</button>
    <button onclick="exportJSON()">Export JSON</button>
    <button onclick="exportCSV()">Export CSV</button>
  </div>
</div>

<!-- Measurements -->
<div class="measurements hidden" id="measurements">
  <div class="measurements-grid">
    <div class="metric"><div class="metric-label">Heart Rate</div><div class="metric-value" id="m_hr">â€”</div></div>
    <div class="metric"><div class="metric-label">PR Interval</div><div class="metric-value" id="m_pr">â€”</div></div>
    <div class="metric"><div class="metric-label">QRS Duration</div><div class="metric-value" id="m_qrs">â€”</div></div>
    <div class="metric"><div class="metric-label">QT Interval</div><div class="metric-value" id="m_qt">â€”</div></div>
    <div class="metric"><div class="metric-label">QTc (Bazett)</div><div class="metric-value" id="m_qtc">â€”</div></div>
    <div class="metric"><div class="metric-label">Axes (P/QRS/T)</div><div class="metric-value" id="m_axes">â€”</div></div>
    <div class="metric" id="diagnosisMetric"><div class="metric-label">Diagnosis</div><div class="metric-value" id="m_dx">â€”</div></div>
    <div class="metric"><div class="metric-label">Age/Sex</div><div class="metric-value" id="m_age">â€”</div></div>
  </div>
</div>

<!-- ECG Canvas -->
<div class="canvas-wrap" id="ecgCanvas" role="img" aria-label="Electrocardiogram display">
  <canvas id="c" tabindex="0" aria-label="ECG waveform - use calipers to measure intervals"></canvas>
</div>

<!-- Caliper Measurements List -->
<div class="caliper-list" id="caliperList" style="display:none">
  <div class="caliper-list-header">
    <span class="caliper-list-title">Caliper Measurements</span>
    <button onclick="clearAllCalipers()" style="font-size:12px;padding:4px 10px">Clear All</button>
  </div>
  <div class="caliper-items" id="caliperItems">
    <div class="caliper-empty">Click two points on the ECG to measure intervals</div>
  </div>
</div>

<!-- Caliper Status Indicator -->
<div class="caliper-status" id="caliperStatus">
  <span class="dot"></span>
  <span>Caliper Mode: Click and drag to measure</span>
</div>

<!-- Footer -->
<div class="footer">
  EKGQuest Lab â€” Educational ECG synthesis and teaching tool.
  Synthetic data for learning only; not for clinical use.
</div>

<script type="module">
import {
  ECG_SCHEMA_VERSION,
  clamp, lerp, medianOfSmallArray, medianWindow, mean,
  fmtMs, fmtBpm, fmtDeg,
  physicsChecks, detectRPeaks,
  buildMedianBeat, fiducialsFromMedian, buildFullFiducialsFromMedian,
  computeAxesFromMedian, computeGlobalMeasurements
} from "./js/ecg-core.js";

// Will be imported dynamically when synthesizer is used
let synthModule = null;

// ============================================================================
// STATE
// ============================================================================

let currentMode = 'quiz';  // 'quiz' or 'teach'
let ecgData = null;
let measurements = null;
let panOffset = 0;
let zoomLevel = 1;

// Advanced Caliper State
let calipersActive = false;
let caliperMeasurements = [];  // Array of completed measurements
let activeCaliperPoint = null; // First point of in-progress measurement
let selectedCaliperId = null;  // Currently selected measurement for editing
let draggingHandle = null;     // { measurementId, handle: 'p1' | 'p2' }
let shiftHeld = false;
let lastMousePos = null;

// Comparison mode state
let referenceECG = null;       // Stored reference ECG for comparison
let referenceMeta = null;      // Metadata about the reference (age, dx, etc.)

// Uploaded image state
let uploadedImage = null;      // HTMLImageElement of uploaded ECG
let uploadedImageName = null;  // Original filename
let imageMode = false;         // Are we displaying an uploaded image?
let imageCalibration = null;   // { pxPerMm, offsetX, offsetY, drawW, drawH } - actual calibration from image

// Calibration mode state
let calibrationMode = false;   // Are we in calibration mode?
let calibrationPoint1 = null;  // First calibration point

const CALIPER_COLORS = ['#1b6dff', '#e91e63', '#4caf50', '#ff9800', '#9c27b0', '#00bcd4'];
let nextCaliperColor = 0;

// ============================================================================
// STATUS MESSAGES
// ============================================================================

let statusTimeout = null;
function showStatus(message, type = 'info', duration = 4000) {
  const el = document.getElementById('statusMsg');
  if (!el) return;

  // Clear previous timeout
  if (statusTimeout) clearTimeout(statusTimeout);

  el.textContent = message;
  el.className = `status-msg visible ${type}`;

  if (duration > 0) {
    statusTimeout = setTimeout(() => {
      el.className = 'status-msg';
    }, duration);
  }
}

function clearStatus() {
  const el = document.getElementById('statusMsg');
  if (el) el.className = 'status-msg';
}

// ============================================================================
// MODE MANAGEMENT
// ============================================================================

window.setMode = function(mode) {
  currentMode = mode;

  // Update buttons and aria-pressed state
  const quizBtn = document.getElementById('quizModeBtn');
  const teachBtn = document.getElementById('teachModeBtn');
  quizBtn.className = mode === 'quiz' ? 'mode-btn active-quiz' : 'mode-btn';
  teachBtn.className = mode === 'teach' ? 'mode-btn active-teach' : 'mode-btn';
  quizBtn.setAttribute('aria-pressed', mode === 'quiz');
  teachBtn.setAttribute('aria-pressed', mode === 'teach');

  // Update reveal button visibility
  document.getElementById('revealBtn').className = mode === 'quiz' ? 'reveal-btn visible' : 'reveal-btn';

  // Update measurements visibility
  const measPanel = document.getElementById('measurements');
  measPanel.className = mode === 'quiz' ? 'measurements hidden' : 'measurements';

  // Update fiducials visibility on canvas
  if (mode === 'teach') {
    document.getElementById('fid').checked = true;
  }
  redraw();
};

window.reveal = function() {
  setMode('teach');
};

// ============================================================================
// TAB MANAGEMENT
// ============================================================================

window.showTab = function(tabId) {
  const tabIds = ['case', 'view', 'tools', 'compare', 'export'];
  document.querySelectorAll('.tab').forEach((t, i) => {
    t.className = tabIds[i] === tabId ? 'tab active' : 'tab';
  });
  document.querySelectorAll('.tab-panel').forEach(p => p.className = 'tab-panel');
  document.getElementById('panel-' + tabId).className = 'tab-panel active';
};

window.toggleAdvanced = function() {
  const content = document.getElementById('advancedContent');
  const icon = document.getElementById('advIcon');
  const btn = document.querySelector('.advanced-toggle');
  const isOpen = content.classList.contains('open');

  if (isOpen) {
    content.classList.remove('open');
    icon.textContent = '+';
    btn?.setAttribute('aria-expanded', 'false');
  } else {
    content.classList.add('open');
    icon.textContent = 'âˆ’';
    btn?.setAttribute('aria-expanded', 'true');
  }
};

// ============================================================================
// COMPARISON MODE
// ============================================================================

window.storeReference = function() {
  if (!ecgData) {
    showStatus('No ECG loaded to store as reference', 'warning');
    return;
  }

  // Deep copy the current ECG data
  referenceECG = JSON.parse(JSON.stringify(ecgData));

  // Store metadata for display
  const age = document.getElementById('ageYears').value;
  const dx = document.getElementById('dx').value;
  const seed = document.getElementById('seed').value;
  referenceMeta = { age, dx, seed };

  // Update UI
  document.getElementById('clearRefBtn').disabled = false;
  document.getElementById('showOverlay').disabled = false;
  document.getElementById('showOverlay').checked = true;
  document.getElementById('refInfo').innerHTML =
    `<strong>Reference:</strong> ${dx}<br>Age: ${age}y, Seed: ${seed}`;

  showStatus('Reference ECG stored', 'success', 2000);
  redraw();
};

window.clearReference = function() {
  referenceECG = null;
  referenceMeta = null;

  // Update UI
  document.getElementById('clearRefBtn').disabled = true;
  document.getElementById('showOverlay').disabled = true;
  document.getElementById('showOverlay').checked = false;
  document.getElementById('refInfo').textContent = 'No reference stored';

  showStatus('Reference cleared', 'info', 2000);
  redraw();
};

// ============================================================================
// SYNTHESIS
// ============================================================================

async function ensureSynth() {
  if (!synthModule) {
    synthModule = await import("./js/ecg-synth-modules.js");
  }
  return synthModule;
}

window.generate = async function() {
  const synth = await ensureSynth();

  const age = parseFloat(document.getElementById('ageYears').value) || 45;
  const sex = document.getElementById('sex').value || null;
  const dx = document.getElementById('dx').value;
  const seed = parseInt(document.getElementById('seed').value) || 7;
  const noiseEnabled = document.getElementById('noise').checked;
  const filtersEnabled = document.getElementById('filters').checked;

  // Use the unified synthesizer which handles all the complexity
  ecgData = synth.synthECGModular(age, dx, seed, {
    sex: sex || null,
    enableNoise: noiseEnabled,
    enableFilters: filtersEnabled,
    artifactParams: noiseEnabled ? synth.ARTIFACT_PRESETS.typical : synth.ARTIFACT_PRESETS.none,
    deviceParams: filtersEnabled ? synth.DEVICE_PRESETS.diagnostic : synth.DEVICE_PRESETS.raw
  });

  updateAfterLoad();
  showStatus('ECG generated', 'success', 2000);
};

window.randomize = function() {
  document.getElementById('seed').value = Math.floor(Math.random() * 99999) + 1;
  generate();
};

// ============================================================================
// FILE LOADING
// ============================================================================

document.getElementById('fileInput').addEventListener('change', async (e) => {
  const file = e.target.files[0];
  if (!file) return;

  try {
    const text = await file.text();

    // Check if this is a CSV file (from WebPlotDigitizer or similar)
    if (file.name.toLowerCase().endsWith('.csv')) {
      const csvData = parseCSVtoECG(text, file.name);
      if (csvData) {
        ecgData = csvData;
        imageMode = false;
        uploadedImage = null;
        document.getElementById('calibrationControls').style.display = 'none';
        updateAfterLoad();
        const leadCount = Object.keys(csvData.leads_uV).length;
        showStatus(`CSV imported: ${leadCount} lead(s) digitized`, 'success');
        return;
      } else {
        showStatus('Could not parse CSV. See console for format help.', 'error');
        console.log(`
CSV Import Format Help:
-----------------------
WebPlotDigitizer format (time, voltage):
  X,Y
  0,0.1
  0.004,0.15
  ...

Multi-lead format (time, lead1, lead2, ...):
  time,I,II,III,V1,V2,V3,V4,V5,V6
  0,0.1,0.2,0.1,0.05,...
  0.002,0.12,0.22,...

Units: Time in seconds, Voltage in mV
        `);
        return;
      }
    }

    const data = JSON.parse(text);

    // Check if this is a teaching case (uploaded image with measurements)
    if (data.type === 'teaching_case' && data.source?.imageData) {
      // Load the embedded image
      const img = new Image();
      img.src = data.source.imageData;
      await new Promise((resolve, reject) => {
        img.onload = resolve;
        img.onerror = () => reject(new Error('Failed to load embedded image'));
      });

      uploadedImage = img;
      uploadedImageName = data.source.filename || 'teaching-case.png';
      imageMode = true;
      ecgData = null;

      // Restore calibration settings
      if (data.calibration) {
        document.getElementById('importSpeed').value = data.calibration.paperSpeed_mm_s || 25;
        document.getElementById('importGain').value = data.calibration.gain_mm_mV || 10;
        if (data.calibration.scale_pxmm) {
          document.getElementById('pxmm').value = data.calibration.scale_pxmm;
        }
      }

      // Restore caliper measurements
      if (data.measurements) {
        caliperMeasurements = data.measurements.map(m => ({
          id: m.id || 'cal_' + Date.now() + Math.random(),
          p1: m.p1,
          p2: m.p2,
          color: m.color || CALIPER_COLORS[0]
        }));
        updateCaliperList();
      }

      document.getElementById('calibrationControls').style.display = 'flex';
      document.getElementById('caseInfo').textContent = `Teaching case: ${uploadedImageName}`;
      document.getElementById('measurements').classList.add('hidden');

      showStatus(`Teaching case loaded with ${caliperMeasurements.length} measurements`, 'success');
      redraw();
    } else {
      // Regular ECG JSON
      ecgData = data;
      imageMode = false;
      uploadedImage = null;
      document.getElementById('calibrationControls').style.display = 'none';
      updateAfterLoad();
      showStatus('File loaded successfully', 'success');
    }
  } catch (err) {
    showStatus('Failed to load file: ' + err.message, 'error', 6000);
  }
});

// Image/PDF upload handler
document.getElementById('imageInput').addEventListener('change', async (e) => {
  const file = e.target.files[0];
  if (!file) return;

  try {
    showStatus('Loading image...', 'info', 0);

    if (file.type === 'application/pdf') {
      // Load PDF.js dynamically
      if (!window.pdfjsLib) {
        const script = document.createElement('script');
        script.src = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js';
        document.head.appendChild(script);
        await new Promise((resolve, reject) => {
          script.onload = resolve;
          script.onerror = () => reject(new Error('Failed to load PDF.js'));
        });
        window.pdfjsLib.GlobalWorkerOptions.workerSrc =
          'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
      }

      // Load and render PDF
      const arrayBuffer = await file.arrayBuffer();
      const pdf = await window.pdfjsLib.getDocument({ data: arrayBuffer }).promise;
      const page = await pdf.getPage(1);

      // Render at high resolution for quality
      const scale = 2.0;
      const viewport = page.getViewport({ scale });

      const tempCanvas = document.createElement('canvas');
      tempCanvas.width = viewport.width;
      tempCanvas.height = viewport.height;
      const tempCtx = tempCanvas.getContext('2d');

      await page.render({ canvasContext: tempCtx, viewport }).promise;

      // Convert to image
      const img = new Image();
      img.src = tempCanvas.toDataURL('image/png');
      await new Promise(resolve => img.onload = resolve);

      uploadedImage = img;
    } else {
      // Load regular image
      const img = new Image();
      img.src = URL.createObjectURL(file);
      await new Promise((resolve, reject) => {
        img.onload = resolve;
        img.onerror = () => reject(new Error('Failed to load image'));
      });
      uploadedImage = img;
    }

    uploadedImageName = file.name;
    imageMode = true;
    ecgData = null;  // Clear synthetic data
    measurements = null;

    // Show calibration controls
    document.getElementById('calibrationControls').style.display = 'flex';

    // Update case info
    document.getElementById('caseInfo').textContent = `Imported: ${file.name}`;
    document.getElementById('measurements').classList.add('hidden');

    // Attempt auto-calibration
    const detected = detectGridSpacing(uploadedImage);
    const statusEl = document.getElementById('calibrationStatus');

    if (detected && detected.confidence > 0.6) {
      imageCalibration = {
        pxPerMm: detected.pxPerMm,
        calibrated: true,
        method: 'auto'
      };
      statusEl.style.display = 'block';
      statusEl.innerHTML = `<strong>Auto-calibrated:</strong> ${detected.pxPerMm.toFixed(1)} px/mm`;
      statusEl.style.color = '#2e7d32';
      document.getElementById('calibrateBtn').textContent = 'Recalibrate';
      showStatus('Image loaded & auto-calibrated â€” ready to measure!', 'success');
    } else {
      imageCalibration = null;
      statusEl.style.display = 'block';
      statusEl.innerHTML = 'Click <strong>Calibrate Grid</strong> for accurate measurements';
      statusEl.style.color = '#ff9800';
      showStatus('Image loaded â€” calibrate for accurate measurements', 'info');
    }

    redraw();

  } catch (err) {
    showStatus('Failed to load image: ' + err.message, 'error', 6000);
    console.error(err);
  }
});

window.clearUploadedImage = function() {
  uploadedImage = null;
  uploadedImageName = null;
  imageMode = false;
  imageCalibration = null;
  calibrationMode = false;
  calibrationPoint1 = null;
  document.getElementById('calibrationControls').style.display = 'none';
  document.getElementById('imageInput').value = '';
  document.getElementById('caseInfo').textContent = 'No case loaded';
  clearAllCalipers();
  redraw();
  showStatus('Image cleared', 'info', 2000);
};

// Load ECG from clipboard (direct paste or clipboard watcher)
window.loadFromClipboard = async function() {
  try {
    // First try native Clipboard API (modern browsers)
    if (navigator.clipboard && navigator.clipboard.read) {
      showStatus('Reading clipboard...', 'info', 0);
      const items = await navigator.clipboard.read();

      for (const item of items) {
        // Check for image
        const imageTypes = item.types.filter(t => t.startsWith('image/'));
        if (imageTypes.length > 0) {
          const blob = await item.getType(imageTypes[0]);
          const img = new Image();
          img.onload = function() {
            processImportedImage(img, 'clipboard-paste.png');
          };
          img.src = URL.createObjectURL(blob);
          return;
        }
      }
      showStatus('No image found in clipboard. Copy an ECG image first (Cmd+C)', 'warning');
    }

    // Fallback: try clipboard watcher API
    try {
      const response = await fetch('http://localhost:8001/latest-ecg');
      if (response.ok) {
        const data = await response.json();
        if (data && data.leads_uV) {
          ecgData = data;
          imageMode = false;
          uploadedImage = null;
          document.getElementById('calibrationControls').style.display = 'none';
          updateAfterLoad();
          showStatus('Loaded from Clipboard Watcher', 'success');
          return;
        }
      }
    } catch (e) {
      // Clipboard watcher not running, that's fine
    }

    showStatus('Copy an ECG image first (Cmd+C), then click this button', 'info');

  } catch (err) {
    console.error('Clipboard error:', err);
    showStatus('Clipboard access denied. Try: drag image directly onto canvas', 'warning');
  }
};

// Also support Cmd+V anywhere to paste
document.addEventListener('paste', async (e) => {
  const items = e.clipboardData?.items;
  if (!items) return;

  for (const item of items) {
    if (item.type.startsWith('image/')) {
      e.preventDefault();
      const blob = item.getAsFile();
      const img = new Image();
      img.onload = function() {
        processImportedImage(img, 'pasted-image.png');
      };
      img.src = URL.createObjectURL(blob);
      return;
    }
  }
});

// Drag and drop from anywhere (including directly from web pages)
const dropZone = document.body;
let dragCounter = 0;

dropZone.addEventListener('dragenter', (e) => {
  e.preventDefault();
  dragCounter++;
  document.body.classList.add('drag-active');
});

dropZone.addEventListener('dragleave', (e) => {
  e.preventDefault();
  dragCounter--;
  if (dragCounter === 0) {
    document.body.classList.remove('drag-active');
  }
});

dropZone.addEventListener('dragover', (e) => {
  e.preventDefault();
  e.dataTransfer.dropEffect = 'copy';
});

dropZone.addEventListener('drop', async (e) => {
  e.preventDefault();
  dragCounter = 0;
  document.body.classList.remove('drag-active');

  // Check for files first
  if (e.dataTransfer.files.length > 0) {
    const file = e.dataTransfer.files[0];
    if (file.type.startsWith('image/')) {
      loadDroppedImage(file);
      return;
    }
  }

  // Check for image URL (dragged from webpage)
  const html = e.dataTransfer.getData('text/html');
  const text = e.dataTransfer.getData('text/plain');

  // Try to extract image URL from HTML
  if (html) {
    const match = html.match(/<img[^>]+src=["']([^"']+)["']/i);
    if (match) {
      loadImageFromURL(match[1]);
      return;
    }
  }

  // Try plain text as URL
  if (text && (text.startsWith('http') || text.startsWith('data:image'))) {
    loadImageFromURL(text);
    return;
  }

  showStatus('Drop an ECG image or image URL', 'info');
});

function loadDroppedImage(file) {
  const img = new Image();
  img.onload = function() {
    processImportedImage(img, file.name);
  };
  img.src = URL.createObjectURL(file);
}

// Central function to process any imported image
function processImportedImage(img, name) {
  uploadedImage = img;
  uploadedImageName = name || 'imported.png';

  // Try auto-calibration
  const detected = detectGridSpacing(img);
  if (detected && detected.confidence > 0.6) {
    imageCalibration = { pxPerMm: detected.pxPerMm, method: 'auto' };

    // Auto-digitize if calibration succeeded
    showStatus('Digitizing ECG...', 'info', 0);
    setTimeout(() => {
      autoDigitizeImage(img, imageCalibration);
    }, 50);
  } else {
    // Fall back to image mode without digitization
    imageMode = true;
    imageCalibration = null;
    document.getElementById('calibrationControls').style.display = 'block';
    document.getElementById('caseInfo').textContent = uploadedImageName;
    showStatus('ECG loaded - click "Digitize" after calibrating for full features', 'info');
    redraw();
  }
}

// Auto-digitize image to waveform data
function autoDigitizeImage(img, calibration) {
  try {
    const extracted = extractWaveformFromImage(img, calibration);

    if (!extracted || Object.keys(extracted.leads_uV).length === 0) {
      // Fall back to image mode
      imageMode = true;
      document.getElementById('calibrationControls').style.display = 'block';
      showStatus('Could not extract trace - showing as image', 'warning');
      redraw();
      return;
    }

    // Fill in missing leads
    const leads = fillMissingLeads(extracted.leads_uV);

    // Create full ECG data structure
    ecgData = {
      schema_version: '1.0',
      fs: extracted.fs,
      duration_s: extracted.duration_s,
      leads_uV: leads,
      targets: {
        synthetic: false,
        imported: true,
        source: 'image',
        filename: uploadedImageName,
        dx: 'Imported ECG',
        import_time: new Date().toISOString()
      },
      integrity: {
        format: 'auto_digitized',
        method: calibration.method
      }
    };

    // Switch to waveform mode (not image mode)
    imageMode = false;
    uploadedImage = null;
    document.getElementById('calibrationControls').style.display = 'none';

    // Update UI
    updateAfterLoad();
    showStatus('ECG digitized! Now works like a generated ECG.', 'success');

  } catch (err) {
    console.error('Digitization error:', err);
    imageMode = true;
    document.getElementById('calibrationControls').style.display = 'block';
    showStatus('Digitization failed - showing as image', 'warning');
    redraw();
  }
}

// Fill in missing leads from available leads
function fillMissingLeads(leads_uV) {
  const LEAD_NAMES = ['I', 'II', 'III', 'aVR', 'aVL', 'aVF', 'V1', 'V2', 'V3', 'V4', 'V5', 'V6'];
  const filled = { ...leads_uV };
  const sampleCount = Object.values(leads_uV)[0]?.length || 5000;

  // If we have Lead II, use it as the basis
  const baseLead = filled['II'] || filled['I'] || Object.values(filled)[0];

  if (!baseLead) {
    // No leads at all, create zeros
    for (const lead of LEAD_NAMES) {
      filled[lead] = new Array(sampleCount).fill(0);
    }
    return filled;
  }

  // Fill limb leads using Einthoven relationships if possible
  const hasI = 'I' in filled;
  const hasII = 'II' in filled;
  const hasIII = 'III' in filled;

  if (!hasI && hasII) {
    // Estimate Lead I from Lead II (assume III ~ 0.4 * II)
    filled['I'] = baseLead.map(v => v * 0.6);
  }
  if (!hasII && hasI) {
    filled['II'] = filled['I'].map(v => v * 1.2);
  }
  if (!hasIII && hasI && hasII) {
    filled['III'] = filled['I'].map((v, i) => filled['II'][i] - v);
  }

  // Fill augmented leads
  if (!('aVR' in filled) && filled['I'] && filled['II']) {
    filled['aVR'] = filled['I'].map((v, i) => -(v + filled['II'][i]) / 2);
  }
  if (!('aVL' in filled) && filled['I'] && filled['II']) {
    filled['aVL'] = filled['I'].map((v, i) => v - filled['II'][i] / 2);
  }
  if (!('aVF' in filled) && filled['I'] && filled['II']) {
    filled['aVF'] = filled['II'].map((v, i) => v - filled['I'][i] / 2);
  }

  // Fill precordial leads with approximations if missing
  const precordialBase = filled['II'] || filled['I'] || baseLead;
  const precordialScales = { 'V1': -0.3, 'V2': -0.1, 'V3': 0.2, 'V4': 0.5, 'V5': 0.7, 'V6': 0.8 };

  for (const [lead, scale] of Object.entries(precordialScales)) {
    if (!(lead in filled)) {
      filled[lead] = precordialBase.map(v => v * scale);
    }
  }

  // Ensure all leads exist
  for (const lead of LEAD_NAMES) {
    if (!(lead in filled)) {
      filled[lead] = new Array(sampleCount).fill(0);
    }
  }

  return filled;
}

async function loadImageFromURL(url) {
  showStatus('Loading image from URL...', 'info', 0);

  try {
    const img = new Image();
    if (!url.startsWith('data:')) {
      img.crossOrigin = 'anonymous';
    }

    img.onload = function() {
      const name = url.startsWith('data:') ? 'pasted-image.png' : (url.split('/').pop() || 'web-image.png');
      processImportedImage(img, name);
    };

    img.onerror = () => {
      showStatus('Could not load image (CORS). Try: copy image, then Cmd+V', 'warning');
    };

    img.src = url;

  } catch (err) {
    showStatus('Failed to load image: ' + err.message, 'error');
  }
}

// Also handle pasting URLs
document.addEventListener('paste', (e) => {
  const text = e.clipboardData?.getData('text/plain');
  if (text && text.match(/^https?:\/\/.*\.(png|jpg|jpeg|gif|webp)/i)) {
    e.preventDefault();
    loadImageFromURL(text);
  }
}, true);

window.startCalibration = function() {
  if (!imageMode || !uploadedImage) {
    showStatus('Upload an image first', 'warning');
    return;
  }

  // First try auto-detection
  showStatus('Detecting grid automatically...', 'info', 0);

  const detected = detectGridSpacing(uploadedImage);

  if (detected && detected.confidence > 0.7) {
    // Auto-calibration succeeded
    imageCalibration = {
      pxPerMm: detected.pxPerMm,
      calibrated: true,
      method: 'auto'
    };

    const statusEl = document.getElementById('calibrationStatus');
    statusEl.style.display = 'block';
    statusEl.innerHTML = `<strong>Auto-calibrated:</strong> ${detected.pxPerMm.toFixed(2)} px/mm (confidence: ${(detected.confidence * 100).toFixed(0)}%)`;
    statusEl.style.color = '#2e7d32';

    document.getElementById('calibrateBtn').textContent = 'Manual Calibrate';
    showStatus(`Auto-calibration complete: ${detected.pxPerMm.toFixed(2)} px/mm`, 'success');
    updateCaliperList();
    redraw();
    return;
  }

  // Fall back to manual calibration
  calibrationMode = true;
  calibrationPoint1 = null;
  calipersActive = false;

  const statusEl = document.getElementById('calibrationStatus');
  statusEl.style.display = 'block';
  statusEl.innerHTML = '<strong>Step 1:</strong> Click the LEFT edge of 5 big grid boxes (25mm)';
  statusEl.style.color = '#1b6dff';

  document.getElementById('calibrateBtn').textContent = 'Cancel Calibration';
  document.getElementById('calibrateBtn').onclick = cancelCalibration;
  document.getElementById('c').style.cursor = 'crosshair';

  showStatus('Auto-detection failed. Click two points exactly 5 big boxes apart.', 'info', 0);
  redraw();
};

// Parse CSV from WebPlotDigitizer or similar tools
function parseCSVtoECG(csvText, filename) {
  try {
    const lines = csvText.trim().split(/\r?\n/);
    if (lines.length < 10) {
      showStatus('CSV file too short - need at least 10 data points', 'error');
      return null;
    }

    // Detect delimiter (comma or tab)
    const delimiter = lines[0].includes('\t') ? '\t' : ',';

    // Parse header row to detect columns
    const headerRow = lines[0].split(delimiter).map(s => s.trim().toLowerCase());

    // Check if first row is a header or data
    const firstRowIsHeader = headerRow.some(h =>
      /^(time|t|x|seconds?|ms|lead|i|ii|iii|avr|avl|avf|v[1-6])$/i.test(h)
    );

    const dataStartRow = firstRowIsHeader ? 1 : 0;

    // Parse all data rows
    const rows = [];
    for (let i = dataStartRow; i < lines.length; i++) {
      const values = lines[i].split(delimiter).map(s => parseFloat(s.trim()));
      if (values.length >= 2 && values.every(v => !isNaN(v))) {
        rows.push(values);
      }
    }

    if (rows.length < 10) {
      showStatus('CSV has too few valid data rows', 'error');
      return null;
    }

    // Determine format based on header or column count
    const numCols = rows[0].length;

    // Standard lead names for multi-column format
    const LEAD_NAMES = ['I', 'II', 'III', 'aVR', 'aVL', 'aVF', 'V1', 'V2', 'V3', 'V4', 'V5', 'V6'];

    let leads_uV = {};
    let fs = 500; // Target sample rate
    let duration_s;

    if (numCols === 2) {
      // WebPlotDigitizer format: time, voltage (single lead)
      // Time is typically in seconds, voltage in mV
      const times = rows.map(r => r[0]);
      const voltages = rows.map(r => r[1]);

      // Detect time units (seconds vs milliseconds)
      const timeRange = Math.max(...times) - Math.min(...times);
      const timeScale = timeRange > 100 ? 0.001 : 1; // If range > 100, assume ms

      // Normalize time to start at 0
      const minTime = Math.min(...times);
      const normalizedTimes = times.map(t => (t - minTime) * timeScale);
      duration_s = Math.max(...normalizedTimes);

      // Detect voltage units (mV vs ÂµV)
      const maxV = Math.max(...voltages.map(Math.abs));
      const voltageScale = maxV > 100 ? 1 : 1000; // If max > 100, assume already ÂµV

      // Resample to uniform 500 Hz
      const numSamples = Math.round(duration_s * fs);
      const resampledVoltages = new Float32Array(numSamples);

      for (let i = 0; i < numSamples; i++) {
        const t = i / fs;
        // Find surrounding points for linear interpolation
        let j = 0;
        while (j < normalizedTimes.length - 1 && normalizedTimes[j + 1] < t) j++;

        if (j >= normalizedTimes.length - 1) {
          resampledVoltages[i] = voltages[voltages.length - 1] * voltageScale;
        } else {
          const t0 = normalizedTimes[j], t1 = normalizedTimes[j + 1];
          const v0 = voltages[j], v1 = voltages[j + 1];
          const alpha = (t - t0) / (t1 - t0 || 1);
          resampledVoltages[i] = (v0 + alpha * (v1 - v0)) * voltageScale;
        }
      }

      // Single lead - assign to Lead II (most common for rhythm strips)
      leads_uV['II'] = Array.from(resampledVoltages);

      // Generate synthetic versions of other leads based on Lead II
      // This is approximate but allows the UI to work
      leads_uV['I'] = leads_uV['II'].map(v => v * 0.6);
      leads_uV['III'] = leads_uV['II'].map((v, i) => leads_uV['II'][i] - leads_uV['I'][i]);
      leads_uV['aVR'] = leads_uV['II'].map((v, i) => -(leads_uV['I'][i] + leads_uV['II'][i]) / 2);
      leads_uV['aVL'] = leads_uV['II'].map((v, i) => leads_uV['I'][i] - leads_uV['II'][i] / 2);
      leads_uV['aVF'] = leads_uV['II'].map((v, i) => leads_uV['II'][i] - leads_uV['I'][i] / 2);
      // Precordial leads - approximate
      leads_uV['V1'] = leads_uV['II'].map(v => v * -0.3);
      leads_uV['V2'] = leads_uV['II'].map(v => v * -0.1);
      leads_uV['V3'] = leads_uV['II'].map(v => v * 0.2);
      leads_uV['V4'] = leads_uV['II'].map(v => v * 0.5);
      leads_uV['V5'] = leads_uV['II'].map(v => v * 0.7);
      leads_uV['V6'] = leads_uV['II'].map(v => v * 0.8);

      showStatus(`Imported single-lead CSV (${rows.length} points) as Lead II`, 'success');

    } else if (numCols >= 3) {
      // Multi-column format: time + multiple leads
      // Try to detect which columns are which leads from header
      let leadColumns = {};

      if (firstRowIsHeader) {
        headerRow.forEach((h, idx) => {
          if (idx === 0) return; // Skip time column
          const leadMatch = h.match(/^(i{1,3}|avr|avl|avf|v[1-6])$/i);
          if (leadMatch) {
            let leadName = leadMatch[1].toUpperCase();
            // Convert roman numerals
            if (leadName === 'I') leadName = 'I';
            else if (leadName === 'II') leadName = 'II';
            else if (leadName === 'III') leadName = 'III';
            leadColumns[leadName] = idx;
          }
        });
      }

      // If no headers matched, assume columns 1-12 are leads I-V6
      if (Object.keys(leadColumns).length === 0) {
        for (let i = 1; i < Math.min(numCols, 13); i++) {
          leadColumns[LEAD_NAMES[i - 1]] = i;
        }
      }

      // Extract time column
      const times = rows.map(r => r[0]);
      const timeRange = Math.max(...times) - Math.min(...times);
      const timeScale = timeRange > 100 ? 0.001 : 1;
      const minTime = Math.min(...times);
      const normalizedTimes = times.map(t => (t - minTime) * timeScale);
      duration_s = Math.max(...normalizedTimes);

      // Detect voltage scale from first lead's data
      const firstLeadIdx = Object.values(leadColumns)[0];
      const firstLeadValues = rows.map(r => r[firstLeadIdx]);
      const maxV = Math.max(...firstLeadValues.map(Math.abs));
      const voltageScale = maxV > 100 ? 1 : 1000;

      // Resample each lead
      const numSamples = Math.round(duration_s * fs);

      for (const [leadName, colIdx] of Object.entries(leadColumns)) {
        const voltages = rows.map(r => r[colIdx]);
        const resampled = new Float32Array(numSamples);

        for (let i = 0; i < numSamples; i++) {
          const t = i / fs;
          let j = 0;
          while (j < normalizedTimes.length - 1 && normalizedTimes[j + 1] < t) j++;

          if (j >= normalizedTimes.length - 1) {
            resampled[i] = voltages[voltages.length - 1] * voltageScale;
          } else {
            const t0 = normalizedTimes[j], t1 = normalizedTimes[j + 1];
            const v0 = voltages[j], v1 = voltages[j + 1];
            const alpha = (t - t0) / (t1 - t0 || 1);
            resampled[i] = (v0 + alpha * (v1 - v0)) * voltageScale;
          }
        }

        leads_uV[leadName] = Array.from(resampled);
      }

      // Fill in missing leads if we have at least limb leads
      const hasI = 'I' in leads_uV;
      const hasII = 'II' in leads_uV;
      const hasIII = 'III' in leads_uV;

      if (hasI && hasII && !hasIII) {
        leads_uV['III'] = leads_uV['I'].map((v, i) => leads_uV['II'][i] - v);
      }
      if (!('aVR' in leads_uV) && hasI && hasII) {
        leads_uV['aVR'] = leads_uV['I'].map((v, i) => -(v + leads_uV['II'][i]) / 2);
      }
      if (!('aVL' in leads_uV) && hasI && hasII) {
        leads_uV['aVL'] = leads_uV['I'].map((v, i) => v - leads_uV['II'][i] / 2);
      }
      if (!('aVF' in leads_uV) && hasI && hasII) {
        leads_uV['aVF'] = leads_uV['II'].map((v, i) => v - leads_uV['I'][i] / 2);
      }

      // Fill in missing precordial leads with zeros
      for (const lead of LEAD_NAMES) {
        if (!(lead in leads_uV)) {
          leads_uV[lead] = new Array(numSamples).fill(0);
        }
      }

      showStatus(`Imported ${Object.keys(leadColumns).length}-lead CSV (${rows.length} points)`, 'success');
    }

    // Build ECG data structure
    const ecgData = {
      fs: fs,
      duration_s: duration_s,
      leads_uV: leads_uV,
      targets: {
        synthetic: false,
        imported: true,
        source: 'csv',
        filename: filename,
        dx: 'Imported ECG'
      },
      integrity: {
        format: 'csv_import',
        original_points: rows.length,
        resampled_to_hz: fs
      }
    };

    return ecgData;

  } catch (err) {
    console.error('CSV parse error:', err);
    showStatus('Failed to parse CSV: ' + err.message, 'error');
    return null;
  }
}

// Automatic grid detection using FFT-like frequency analysis
function detectGridSpacing(img) {
  try {
    // Create a canvas to analyze the image
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');

    // Use a reasonable size for analysis
    const maxSize = 800;
    const scale = Math.min(1, maxSize / Math.max(img.width, img.height));
    canvas.width = img.width * scale;
    canvas.height = img.height * scale;
    ctx.drawImage(img, 0, 0, canvas.width, canvas.height);

    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
    const data = imageData.data;

    // Detect red/pink grid lines (ECG paper is typically red grid)
    // We'll look for horizontal lines and measure their spacing
    const rowRedness = [];
    const colRedness = [];

    // Calculate "redness" for each row and column
    for (let y = 0; y < canvas.height; y++) {
      let rowSum = 0;
      for (let x = 0; x < canvas.width; x++) {
        const i = (y * canvas.width + x) * 4;
        const r = data[i], g = data[i+1], b = data[i+2];
        // Red-ish pixels (more red than green/blue)
        if (r > 100 && r > g * 1.2 && r > b * 1.2) {
          rowSum++;
        }
      }
      rowRedness.push(rowSum);
    }

    for (let x = 0; x < canvas.width; x++) {
      let colSum = 0;
      for (let y = 0; y < canvas.height; y++) {
        const i = (y * canvas.width + x) * 4;
        const r = data[i], g = data[i+1], b = data[i+2];
        if (r > 100 && r > g * 1.2 && r > b * 1.2) {
          colSum++;
        }
      }
      colRedness.push(colSum);
    }

    // Find peaks in the redness arrays (these are grid lines)
    const findPeaks = (arr, threshold) => {
      const peaks = [];
      const mean = arr.reduce((a, b) => a + b, 0) / arr.length;
      const thresh = mean * threshold;

      for (let i = 2; i < arr.length - 2; i++) {
        if (arr[i] > thresh &&
            arr[i] > arr[i-1] && arr[i] > arr[i+1] &&
            arr[i] > arr[i-2] && arr[i] > arr[i+2]) {
          peaks.push(i);
        }
      }
      return peaks;
    };

    const verticalPeaks = findPeaks(colRedness, 1.5);

    if (verticalPeaks.length < 5) {
      return null; // Not enough grid lines detected
    }

    // Calculate spacings between consecutive peaks
    const spacings = [];
    for (let i = 1; i < verticalPeaks.length; i++) {
      spacings.push(verticalPeaks[i] - verticalPeaks[i-1]);
    }

    // Find the most common spacing (mode)
    const spacingCounts = {};
    spacings.forEach(s => {
      // Round to nearest 2 pixels for grouping
      const rounded = Math.round(s / 2) * 2;
      spacingCounts[rounded] = (spacingCounts[rounded] || 0) + 1;
    });

    let bestSpacing = 0;
    let bestCount = 0;
    for (const [spacing, count] of Object.entries(spacingCounts)) {
      if (count > bestCount) {
        bestCount = count;
        bestSpacing = parseInt(spacing);
      }
    }

    if (bestSpacing < 5 || bestCount < 3) {
      return null; // Spacing too small or inconsistent
    }

    // Determine if this is 1mm or 5mm grid spacing
    // Standard ECG: 1mm = 0.04s at 25mm/s, 5mm = 0.2s (big box)
    // Check if there's a 5x multiple pattern
    const smallSpacing = bestSpacing;

    // Assume detected spacing is 1mm small boxes
    // Convert to pixels per mm (accounting for image scaling)
    const pxPerMm = smallSpacing / scale;

    // Confidence based on consistency of spacing detection
    const variance = spacings.reduce((sum, s) => sum + Math.pow(s - bestSpacing, 2), 0) / spacings.length;
    const stdDev = Math.sqrt(variance);
    const confidence = Math.max(0, 1 - (stdDev / bestSpacing));

    return {
      pxPerMm: pxPerMm,
      smallBoxPx: smallSpacing,
      bigBoxPx: smallSpacing * 5,
      confidence: confidence,
      gridLines: verticalPeaks.length
    };

  } catch (err) {
    console.error('Grid detection failed:', err);
    return null;
  }
}

// Digitize ECG trace from uploaded image
window.digitizeECG = async function() {
  if (!imageMode || !uploadedImage) {
    showStatus('Upload an image first', 'warning');
    return;
  }

  // Need calibration for accurate digitization
  if (!imageCalibration?.calibrated) {
    showStatus('Please calibrate the grid first for accurate digitization', 'warning');
    startCalibration();
    return;
  }

  showStatus('Digitizing ECG trace...', 'info', 0);

  try {
    // Small delay to let the UI update
    await new Promise(r => setTimeout(r, 50));

    const result = extractWaveformFromImage(uploadedImage, imageCalibration);

    if (!result || !result.leads_uV || Object.keys(result.leads_uV).length === 0) {
      showStatus('Could not detect ECG trace. Try a clearer image.', 'error');
      return;
    }

    // Create ECG data structure matching synthetic format
    ecgData = {
      fs: result.fs,
      duration_s: result.duration_s,
      leads_uV: result.leads_uV,
      targets: {
        synthetic: false,
        digitized: true,
        source: uploadedImageName,
        age_years: null,
        sex: null,
        dx: 'Digitized from image'
      },
      integrity: {
        digitization_method: 'trace_extraction',
        source_pxPerMm: imageCalibration.pxPerMm,
        source_paperSpeed: parseInt(document.getElementById('importSpeed').value),
        source_gain: parseInt(document.getElementById('importGain').value)
      }
    };

    // Exit image mode - now it's a real ECG
    imageMode = false;
    uploadedImage = null;
    document.getElementById('calibrationControls').style.display = 'none';
    document.getElementById('imageInput').value = '';

    // Run standard ECG analysis
    updateAfterLoad();

    const leadCount = Object.keys(result.leads_uV).length;
    showStatus(`Digitized ${leadCount} lead(s) â€” now a full ECG!`, 'success');

  } catch (err) {
    console.error('Digitization failed:', err);
    showStatus('Digitization failed: ' + err.message, 'error');
  }
};

function extractWaveformFromImage(img, calibration) {
  const canvas = document.createElement('canvas');
  const ctx = canvas.getContext('2d');

  canvas.width = img.width;
  canvas.height = img.height;
  ctx.drawImage(img, 0, 0);

  const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
  const data = imageData.data;
  const width = canvas.width;
  const height = canvas.height;

  const pxPerMm = calibration.pxPerMm;
  const paperSpeed = parseInt(document.getElementById('importSpeed').value); // mm/s
  const gain = parseInt(document.getElementById('importGain').value); // mm/mV

  // Detect lead regions (horizontal bands where traces are)
  const leadRegions = detectLeadRegions(data, width, height);

  if (leadRegions.length === 0) {
    // Fall back to single lead using full image
    leadRegions.push({ y1: 0, y2: height, label: 'II' });
  }

  const leads_uV = {};
  const fs = 500; // Output sample rate

  // Process each lead region
  for (const region of leadRegions) {
    const trace = extractTraceFromRegion(data, width, height, region.y1, region.y2);

    if (trace.length < 10) continue;

    // Convert pixel positions to voltage
    const centerY = (region.y1 + region.y2) / 2;
    const voltages = trace.map(t => {
      if (t.y === null) return 0;
      // y increases downward, voltage increases upward
      const mm_from_center = (centerY - t.y) / pxPerMm;
      const mV = mm_from_center / gain;
      return Math.round(mV * 1000); // Convert to ÂµV
    });

    // Resample to target sample rate
    const duration_s = (trace.length / pxPerMm) / paperSpeed;
    const targetSamples = Math.round(duration_s * fs);
    const resampled = resampleSignal(voltages, targetSamples);

    // Apply light smoothing to reduce digitization noise
    const smoothed = smoothSignal(resampled, 3);

    leads_uV[region.label] = smoothed;
  }

  // If we only got one lead, also create derived leads for compatibility
  if (Object.keys(leads_uV).length === 1) {
    const mainLead = Object.values(leads_uV)[0];
    // Just use the same trace for lead II if that's all we have
    if (!leads_uV['II']) {
      leads_uV['II'] = mainLead;
    }
  }

  const duration_s = Object.values(leads_uV)[0]?.length / fs || 10;

  return {
    leads_uV,
    fs,
    duration_s
  };
}

function detectLeadRegions(data, width, height) {
  // Scan for horizontal bands of trace activity
  // Look for rows with dark pixels (trace) vs light pixels (background)

  const rowDarkness = [];
  for (let y = 0; y < height; y++) {
    let darkCount = 0;
    for (let x = 0; x < width; x++) {
      const i = (y * width + x) * 4;
      const r = data[i], g = data[i+1], b = data[i+2];
      const brightness = (r + g + b) / 3;
      // Count dark pixels (trace is usually black/dark)
      if (brightness < 80) darkCount++;
    }
    rowDarkness.push(darkCount);
  }

  // Find regions with significant trace activity
  const threshold = Math.max(...rowDarkness) * 0.1;
  const regions = [];
  let inRegion = false;
  let regionStart = 0;

  for (let y = 0; y < height; y++) {
    if (rowDarkness[y] > threshold && !inRegion) {
      inRegion = true;
      regionStart = y;
    } else if (rowDarkness[y] <= threshold && inRegion) {
      inRegion = false;
      if (y - regionStart > 20) { // Minimum region height
        regions.push({ y1: regionStart, y2: y });
      }
    }
  }

  if (inRegion && height - regionStart > 20) {
    regions.push({ y1: regionStart, y2: height });
  }

  // Assign standard lead labels based on position
  const leadLabels = ['I', 'II', 'III', 'aVR', 'aVL', 'aVF', 'V1', 'V2', 'V3', 'V4', 'V5', 'V6'];
  regions.forEach((r, i) => {
    r.label = leadLabels[i] || `Lead${i+1}`;
  });

  return regions;
}

function extractTraceFromRegion(data, width, height, y1, y2) {
  const trace = [];

  for (let x = 0; x < width; x++) {
    // Find the darkest pixel in this column within the region
    let darkestY = null;
    let darkestValue = 255;

    for (let y = y1; y < y2; y++) {
      const i = (y * width + x) * 4;
      const r = data[i], g = data[i+1], b = data[i+2];

      // Look for dark pixels that are NOT red (exclude grid lines)
      const isRed = r > 100 && r > g * 1.3 && r > b * 1.3;
      if (isRed) continue;

      const brightness = (r + g + b) / 3;

      if (brightness < darkestValue && brightness < 120) {
        darkestValue = brightness;
        darkestY = y;
      }
    }

    trace.push({ x, y: darkestY, brightness: darkestValue });
  }

  // Fill gaps using interpolation
  for (let i = 1; i < trace.length - 1; i++) {
    if (trace[i].y === null) {
      // Find nearest valid points
      let left = i - 1;
      while (left >= 0 && trace[left].y === null) left--;

      let right = i + 1;
      while (right < trace.length && trace[right].y === null) right++;

      if (left >= 0 && right < trace.length && trace[left].y !== null && trace[right].y !== null) {
        // Interpolate
        const t = (i - left) / (right - left);
        trace[i].y = trace[left].y + t * (trace[right].y - trace[left].y);
      }
    }
  }

  return trace;
}

function resampleSignal(signal, targetLength) {
  if (signal.length === targetLength) return signal;

  const result = new Array(targetLength);
  const ratio = signal.length / targetLength;

  for (let i = 0; i < targetLength; i++) {
    const srcIdx = i * ratio;
    const srcIdxFloor = Math.floor(srcIdx);
    const srcIdxCeil = Math.min(srcIdxFloor + 1, signal.length - 1);
    const t = srcIdx - srcIdxFloor;

    result[i] = Math.round(signal[srcIdxFloor] * (1 - t) + signal[srcIdxCeil] * t);
  }

  return result;
}

function smoothSignal(signal, windowSize) {
  const result = new Array(signal.length);
  const halfWindow = Math.floor(windowSize / 2);

  for (let i = 0; i < signal.length; i++) {
    let sum = 0;
    let count = 0;

    for (let j = -halfWindow; j <= halfWindow; j++) {
      const idx = i + j;
      if (idx >= 0 && idx < signal.length) {
        sum += signal[idx];
        count++;
      }
    }

    result[i] = Math.round(sum / count);
  }

  return result;
}

window.cancelCalibration = function() {
  calibrationMode = false;
  calibrationPoint1 = null;

  const statusEl = document.getElementById('calibrationStatus');
  statusEl.style.display = 'none';

  document.getElementById('calibrateBtn').textContent = 'Calibrate Grid';
  document.getElementById('calibrateBtn').onclick = startCalibration;
  document.getElementById('c').style.cursor = 'default';

  clearStatus();
  redraw();
};

function handleCalibrationClick(x, y) {
  const statusEl = document.getElementById('calibrationStatus');

  if (!calibrationPoint1) {
    // First point
    calibrationPoint1 = { x, y };
    statusEl.innerHTML = '<strong>Step 2:</strong> Click the RIGHT edge of those same 5 boxes';

    // Draw marker at first point
    redraw();
    const canvas = document.getElementById('c');
    const ctx = canvas.getContext('2d');
    ctx.fillStyle = '#1b6dff';
    ctx.beginPath();
    ctx.arc(x, y, 6, 0, Math.PI * 2);
    ctx.fill();
    ctx.strokeStyle = '#fff';
    ctx.lineWidth = 2;
    ctx.stroke();

  } else {
    // Second point - calculate calibration
    const dx = Math.abs(x - calibrationPoint1.x);

    if (dx < 20) {
      showStatus('Points too close together. Try again.', 'error');
      calibrationPoint1 = null;
      statusEl.innerHTML = '<strong>Step 1:</strong> Click the LEFT edge of 5 big grid boxes (25mm)';
      return;
    }

    // 5 big boxes = 25mm
    const pxPerMm = dx / 25;

    // Store calibration
    imageCalibration = {
      ...imageCalibration,
      pxPerMm: pxPerMm,
      calibrated: true
    };

    // Complete calibration
    calibrationMode = false;
    calibrationPoint1 = null;

    statusEl.innerHTML = `<strong>Calibrated:</strong> ${pxPerMm.toFixed(2)} px/mm (${(pxPerMm * 25).toFixed(0)}px = 25mm)`;
    statusEl.style.color = '#2e7d32';

    document.getElementById('calibrateBtn').textContent = 'Recalibrate';
    document.getElementById('calibrateBtn').onclick = startCalibration;
    document.getElementById('c').style.cursor = 'default';

    showStatus(`Calibration complete: ${pxPerMm.toFixed(2)} pixels/mm â€” measurements are now accurate`, 'success');
    redraw();
  }
}

// ============================================================================
// UPDATE AFTER LOAD
// ============================================================================

function updateAfterLoad() {
  if (!ecgData) return;

  // Update badge
  const badge = document.getElementById('sourceBadge');
  if (ecgData.targets?.synthetic) {
    badge.textContent = 'SYNTHETIC';
    badge.className = 'header-badge badge-synth';
  } else {
    badge.textContent = 'REAL';
    badge.className = 'header-badge badge-real';
  }

  // Compute measurements
  computeMeasurements();

  // Update case info
  const dx = ecgData.targets?.dx || 'Unknown';
  const age = ecgData.targets?.age_years;
  const sex = ecgData.targets?.sex;
  const sexLabel = sex === 'male' ? 'M' : sex === 'female' ? 'F' : '';
  const ageStr = age != null ? `${age.toFixed(0)}y` : '';
  const demo = [ageStr, sexLabel].filter(Boolean).join(' ');
  document.getElementById('caseInfo').textContent = demo
    ? `${dx}, ${demo}`
    : dx;

  // Draw
  redraw();
}

// ============================================================================
// MEASUREMENTS
// ============================================================================

function computeMeasurements() {
  if (!ecgData) return;

  const { fs, leads_uV } = ecgData;
  const leadII = leads_uV.II || leads_uV['II'];
  if (!leadII) return;

  // Detect R peaks
  const rPeaks = detectRPeaks(leadII, fs);
  if (rPeaks.length < 2) return;

  // Compute HR from RR intervals
  const rr = [];
  for (let i = 1; i < rPeaks.length; i++) {
    rr.push((rPeaks[i] - rPeaks[i-1]) / fs);
  }
  const meanRR = mean(rr);
  const hr = 60 / meanRR;

  // Build median beat and compute intervals
  const medianBeat = buildMedianBeat(leadII, rPeaks, fs);
  const fids = fiducialsFromMedian(medianBeat, fs);
  const globalMeas = computeGlobalMeasurements(fids, fs, meanRR);

  measurements = {
    hr,
    pr: globalMeas.PR_ms,
    qrs: globalMeas.QRS_ms,
    qt: globalMeas.QT_ms,
    qtcBazett: globalMeas.QTc_Bazett_ms,
    qtcFrid: globalMeas.QTc_Fridericia_ms,
    axes: computeAxesFromMedian ? computeAxesFromMedian(leads_uV, rPeaks, fs) : null,
    rPeaks,
    fids,
    medianBeat
  };

  // Update display
  const age = ecgData.targets?.age_years || 8;
  document.getElementById('m_hr').innerHTML = fmtMeasure(hr, 'bpm', 'HR', age);
  document.getElementById('m_pr').innerHTML = fmtMeasure(measurements.pr, 'ms', 'PR', age);
  document.getElementById('m_qrs').innerHTML = fmtMeasure(measurements.qrs, 'ms', 'QRS', age);
  document.getElementById('m_qt').textContent = measurements.qt ? `${Math.round(measurements.qt)} ms` : 'â€”';
  document.getElementById('m_qtc').innerHTML = fmtMeasure(measurements.qtcBazett, 'ms', 'QTc', age);

  if (measurements.axes) {
    const { P, QRS, T } = measurements.axes;
    document.getElementById('m_axes').textContent = `${Math.round(P)}Â° / ${Math.round(QRS)}Â° / ${Math.round(T)}Â°`;
  }

  document.getElementById('m_dx').textContent = ecgData.targets?.dx || 'â€”';
  const ageVal = ecgData.targets?.age_years;
  const sexVal = ecgData.targets?.sex;
  const sexStr = sexVal === 'male' ? 'M' : sexVal === 'female' ? 'F' : '';
  const ageDisplay = ageVal != null ? `${ageVal.toFixed(0)}y` : '';
  document.getElementById('m_age').textContent = [ageDisplay, sexStr].filter(Boolean).join(' ') || 'â€”';
}

function fmtMeasure(value, unit, param, age) {
  if (value == null) return 'â€”';
  const valStr = unit === 'bpm' ? `${Math.round(value)} bpm` : `${Math.round(value)} ms`;
  // Could add age-appropriate normal range checking here
  return valStr;
}

// ============================================================================
// DRAWING
// ============================================================================

function redraw() {
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');
  const dpr = window.devicePixelRatio || 1;

  // Set canvas size
  const rect = canvas.getBoundingClientRect();
  canvas.width = rect.width * dpr;
  canvas.height = rect.height * dpr;
  ctx.scale(dpr, dpr);

  // Clear
  ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--paper');
  ctx.fillRect(0, 0, rect.width, rect.height);

  // Handle uploaded image mode
  if (imageMode && uploadedImage) {
    drawUploadedImage(ctx, rect.width, rect.height);
    return;
  }

  if (!ecgData) {
    ctx.fillStyle = '#888';
    ctx.font = '16px system-ui';
    ctx.textAlign = 'center';
    ctx.fillText('Generate or load an ECG to begin', rect.width / 2, rect.height / 2);
    return;
  }

  const layout = document.getElementById('layout').value;
  const speed = parseInt(document.getElementById('speed').value);
  const gain = parseInt(document.getElementById('gain').value);
  const pxmm = parseInt(document.getElementById('pxmm').value);
  const showFid = document.getElementById('fid').checked && currentMode === 'teach';

  const { fs, leads_uV } = ecgData;
  const mmPerSec = speed;
  const mmPerMV = gain;
  const pxPerMm = pxmm;

  // Draw based on layout
  if (layout === 'stacked') {
    drawStackedLayout(ctx, rect.width, rect.height, leads_uV, fs, pxPerMm, mmPerSec, mmPerMV, showFid);
  } else {
    draw12LeadLayout(ctx, rect.width, rect.height, leads_uV, fs, pxPerMm, mmPerSec, mmPerMV, showFid);
  }
}

function drawUploadedImage(ctx, w, h) {
  const img = uploadedImage;
  const speed = parseInt(document.getElementById('importSpeed')?.value || 25);
  const gain = parseInt(document.getElementById('importGain')?.value || 10);
  const pxmm = parseInt(document.getElementById('pxmm')?.value || 4);

  // Draw grid first (helps with calibration)
  drawGrid(ctx, w, h, pxmm);

  // Calculate scaling to fit image while maintaining aspect ratio
  const imgAspect = img.width / img.height;
  const canvasAspect = w / h;

  let drawW, drawH, offsetX, offsetY;

  if (imgAspect > canvasAspect) {
    // Image is wider than canvas
    drawW = w;
    drawH = w / imgAspect;
    offsetX = 0;
    offsetY = (h - drawH) / 2;
  } else {
    // Image is taller than canvas
    drawH = h;
    drawW = h * imgAspect;
    offsetX = (w - drawW) / 2;
    offsetY = 0;
  }

  // Draw the image
  ctx.drawImage(img, offsetX, offsetY, drawW, drawH);

  // Draw info overlay
  ctx.fillStyle = 'rgba(0,0,0,0.7)';
  ctx.fillRect(5, 5, 180, 50);
  ctx.fillStyle = '#fff';
  ctx.font = '11px system-ui';
  ctx.textAlign = 'left';
  ctx.fillText(`Speed: ${speed} mm/s | Gain: ${gain} mm/mV`, 10, 22);
  ctx.fillText(`Image: ${uploadedImageName || 'Unknown'}`, 10, 38);

  // Draw calipers on top
  drawAllCalipers(ctx, w, h);

  // Draw in-progress caliper
  if (activeCaliperPoint && lastMousePos) {
    let endPoint = lastMousePos;
    if (shiftHeld) {
      endPoint = constrainPoint(endPoint.x, endPoint.y, activeCaliperPoint.x, activeCaliperPoint.y, true);
    }
    const color = CALIPER_COLORS[nextCaliperColor % CALIPER_COLORS.length];
    drawSingleCaliper(ctx, activeCaliperPoint, endPoint, color, false, null);
  }
}

function drawStackedLayout(ctx, w, h, leads, fs, pxPerMm, mmPerSec, mmPerMV, showFid) {
  const leadOrder = ['I', 'II', 'III', 'aVR', 'aVL', 'aVF', 'V1', 'V2', 'V3', 'V4', 'V5', 'V6'];
  const available = leadOrder.filter(l => leads[l]);
  const rowCount = available.length;
  const rowH = h / rowCount;

  // Draw grid
  drawGrid(ctx, w, h, pxPerMm);

  const pxPerSample = (pxPerMm * mmPerSec) / fs;
  const uvPerPx = 1000 / (pxPerMm * mmPerMV);

  // Check if we should show reference overlay
  const showOverlay = document.getElementById('showOverlay')?.checked && referenceECG;
  const showDiff = document.getElementById('showDiff')?.checked;

  // Draw reference ECG first (underneath) if overlay enabled
  if (showOverlay && referenceECG?.leads_uV) {
    const refLeads = referenceECG.leads_uV;
    const refFs = referenceECG.fs || fs;
    const refPxPerSample = (pxPerMm * mmPerSec) / refFs;

    available.forEach((lead, i) => {
      if (!refLeads[lead]) return;
      const y0 = (i + 0.5) * rowH;
      const signal = refLeads[lead];

      ctx.strokeStyle = 'rgba(0, 100, 200, 0.5)';
      ctx.lineWidth = 1.5;
      ctx.lineCap = 'round';
      ctx.lineJoin = 'round';
      ctx.beginPath();

      for (let j = 0; j < signal.length; j++) {
        const x = 40 + j * refPxPerSample + panOffset;
        if (x < 0 || x > w) continue;
        const yVal = y0 - signal[j] / uvPerPx;
        if (j === 0) ctx.moveTo(x, yVal);
        else ctx.lineTo(x, yVal);
      }
      ctx.stroke();
    });
  }

  // Draw each lead (current ECG)
  available.forEach((lead, i) => {
    const y0 = (i + 0.5) * rowH;
    const signal = leads[lead];

    // Lead label
    ctx.fillStyle = '#333';
    ctx.font = 'bold 11px "Courier New", Consolas, monospace';
    ctx.textAlign = 'left';
    ctx.fillText(lead, 8, y0 - rowH/2 + 14);

    // Determine trace color based on diff highlighting
    let strokeColor = '#1a1a1a';
    if (showDiff && showOverlay && referenceECG?.leads_uV?.[lead]) {
      // Calculate RMS difference for this lead
      const refSignal = referenceECG.leads_uV[lead];
      const minLen = Math.min(signal.length, refSignal.length);
      let sumSq = 0;
      for (let k = 0; k < minLen; k++) {
        sumSq += Math.pow(signal[k] - refSignal[k], 2);
      }
      const rms = Math.sqrt(sumSq / minLen);
      // Color based on difference magnitude (red = high, green = low)
      if (rms > 300) strokeColor = '#c62828';      // Major difference (red)
      else if (rms > 100) strokeColor = '#ef6c00'; // Moderate (orange)
      else strokeColor = '#2e7d32';                // Similar (green)
    }

    // Draw trace
    ctx.strokeStyle = strokeColor;
    ctx.lineWidth = 1.3;
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';
    ctx.beginPath();

    for (let j = 0; j < signal.length; j++) {
      const x = 40 + j * pxPerSample + panOffset;
      if (x < 0 || x > w) continue;
      const yVal = y0 - signal[j] / uvPerPx;
      if (j === 0) ctx.moveTo(x, yVal);
      else ctx.lineTo(x, yVal);
    }
    ctx.stroke();
  });

  // Draw fiducials if enabled
  if (showFid && measurements?.fids && measurements?.rPeaks) {
    drawFiducials(ctx, leads.II || leads['II'], fs, measurements, h / 2, pxPerMm * mmPerSec / fs);
  }

  // Draw calipers (advanced system)
  drawAllCalipers(ctx, w, h);

  // Draw legend if overlay is active
  if (showOverlay) {
    ctx.font = '10px system-ui';
    ctx.fillStyle = 'rgba(0, 100, 200, 0.8)';
    ctx.fillText('Reference', w - 70, 15);
    ctx.fillStyle = '#1a1a1a';
    ctx.fillText('Current', w - 70, 28);
  }
}

function draw12LeadLayout(ctx, w, h, leads, fs, pxPerMm, mmPerSec, mmPerMV, showFid) {
  // Simplified 12-lead layout (3x4 grid + rhythm strip)
  drawGrid(ctx, w, h, pxPerMm);

  const leadGroups = [
    ['I', 'aVR', 'V1', 'V4'],
    ['II', 'aVL', 'V2', 'V5'],
    ['III', 'aVF', 'V3', 'V6']
  ];

  const colW = w / 4;
  const rowH = (h - 100) / 3;
  const rhythmH = 80;

  // Check if we should show reference overlay
  const showOverlay = document.getElementById('showOverlay')?.checked && referenceECG;
  const refLeads = referenceECG?.leads_uV;
  const refFs = referenceECG?.fs || fs;

  // Helper to draw a trace segment
  const drawTrace = (signal, x0, y0, ci, samplesPerCol, pxPerSample, uvPerPx, color) => {
    const startSample = ci * samplesPerCol;
    const endSample = Math.min(startSample + samplesPerCol, signal.length);
    ctx.strokeStyle = color;
    ctx.lineWidth = 1.3;
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';
    ctx.beginPath();
    for (let j = startSample; j < endSample; j++) {
      const x = x0 + (j - startSample) * pxPerSample;
      const yVal = y0 - signal[j] / uvPerPx;
      if (j === startSample) ctx.moveTo(x, yVal);
      else ctx.lineTo(x, yVal);
    }
    ctx.stroke();
  };

  leadGroups.forEach((row, ri) => {
    row.forEach((lead, ci) => {
      if (!leads[lead]) return;
      const x0 = ci * colW + 10;
      const y0 = ri * rowH + rowH / 2;

      // Label
      ctx.fillStyle = '#333';
      ctx.font = 'bold 10px "Courier New", Consolas, monospace';
      ctx.fillText(lead, x0, ri * rowH + 14);

      const signal = leads[lead];
      const samplesPerCol = Math.floor(2.5 * fs);
      const pxPerSample = (colW - 20) / samplesPerCol;
      const uvPerPx = 1000 / (pxPerMm * mmPerMV);

      // Draw reference first if overlay enabled
      if (showOverlay && refLeads?.[lead]) {
        const refSamplesPerCol = Math.floor(2.5 * refFs);
        const refPxPerSample = (colW - 20) / refSamplesPerCol;
        drawTrace(refLeads[lead], x0, y0, ci, refSamplesPerCol, refPxPerSample, uvPerPx, 'rgba(0, 100, 200, 0.5)');
      }

      // Draw current trace
      drawTrace(signal, x0, y0, ci, samplesPerCol, pxPerSample, uvPerPx, '#1a1a1a');
    });
  });

  // Rhythm strip (Lead II, full duration)
  const rhythmY = h - rhythmH / 2 - 10;
  ctx.fillStyle = '#333';
  ctx.font = 'bold 10px "Courier New", Consolas, monospace';
  ctx.fillText('II (rhythm)', 10, h - rhythmH);

  const uvPerPx = 1000 / (pxPerMm * mmPerMV);

  // Draw reference rhythm strip if overlay enabled
  if (showOverlay && refLeads?.II) {
    const refSignal = refLeads.II;
    const refPxPerSample = (w - 40) / refSignal.length;
    ctx.strokeStyle = 'rgba(0, 100, 200, 0.5)';
    ctx.lineWidth = 1.5;
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';
    ctx.beginPath();
    for (let j = 0; j < refSignal.length; j++) {
      const x = 20 + j * refPxPerSample;
      const yVal = rhythmY - refSignal[j] / uvPerPx;
      if (j === 0) ctx.moveTo(x, yVal);
      else ctx.lineTo(x, yVal);
    }
    ctx.stroke();
  }

  // Draw current rhythm strip
  if (leads.II) {
    const signal = leads.II;
    const pxPerSample = (w - 40) / signal.length;

    ctx.strokeStyle = '#1a1a1a';
    ctx.lineWidth = 1.3;
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';
    ctx.beginPath();

    for (let j = 0; j < signal.length; j++) {
      const x = 20 + j * pxPerSample;
      const yVal = rhythmY - signal[j] / uvPerPx;
      if (j === 0) ctx.moveTo(x, yVal);
      else ctx.lineTo(x, yVal);
    }
    ctx.stroke();
  }

  // Draw calipers (advanced system)
  drawAllCalipers(ctx, w, h);

  // Draw legend if overlay is active
  if (showOverlay) {
    ctx.font = '10px system-ui';
    ctx.fillStyle = 'rgba(0, 100, 200, 0.8)';
    ctx.fillText('Reference', w - 70, 15);
    ctx.fillStyle = '#1a1a1a';
    ctx.fillText('Current', w - 70, 28);
  }
}

function drawGrid(ctx, w, h, pxPerMm) {
  // Add subtle paper texture (thermal paper effect)
  addPaperTexture(ctx, w, h);

  // 1mm grid - subtle
  ctx.strokeStyle = 'rgba(185,55,55,0.20)';
  ctx.lineWidth = 0.6;
  for (let x = 0; x < w; x += pxPerMm) {
    ctx.beginPath();
    ctx.moveTo(x + 0.5, 0);
    ctx.lineTo(x + 0.5, h);
    ctx.stroke();
  }
  for (let y = 0; y < h; y += pxPerMm) {
    ctx.beginPath();
    ctx.moveTo(0, y + 0.5);
    ctx.lineTo(w, y + 0.5);
    ctx.stroke();
  }

  // 5mm grid - more prominent
  ctx.strokeStyle = 'rgba(175,45,45,0.50)';
  ctx.lineWidth = 1.2;
  for (let x = 0; x < w; x += pxPerMm * 5) {
    ctx.beginPath();
    ctx.moveTo(x + 0.5, 0);
    ctx.lineTo(x + 0.5, h);
    ctx.stroke();
  }
  for (let y = 0; y < h; y += pxPerMm * 5) {
    ctx.beginPath();
    ctx.moveTo(0, y + 0.5);
    ctx.lineTo(w, y + 0.5);
    ctx.stroke();
  }
}

// Add subtle paper texture to simulate thermal/ECG paper
function addPaperTexture(ctx, w, h) {
  const imageData = ctx.getImageData(0, 0, w, h);
  const data = imageData.data;

  // Very subtle noise - mimics paper grain
  for (let i = 0; i < data.length; i += 4) {
    const noise = (Math.random() - 0.5) * 6; // Very subtle
    data[i] = Math.max(0, Math.min(255, data[i] + noise));     // R
    data[i+1] = Math.max(0, Math.min(255, data[i+1] + noise)); // G
    data[i+2] = Math.max(0, Math.min(255, data[i+2] + noise)); // B
  }

  ctx.putImageData(imageData, 0, 0);
}

function drawFiducials(ctx, signal, fs, meas, y0, pxPerSample) {
  if (!meas.rPeaks) return;

  ctx.fillStyle = 'rgba(27,109,255,0.15)';
  ctx.strokeStyle = 'rgba(27,109,255,0.6)';

  meas.rPeaks.forEach(rIdx => {
    const x = 40 + rIdx * pxPerSample + panOffset;
    if (x < 0 || x > 2000) return;

    // R peak marker
    ctx.beginPath();
    ctx.arc(x, y0 - 20, 4, 0, Math.PI * 2);
    ctx.fill();
    ctx.stroke();
  });
}

// ============================================================================
// ADVANCED CALIPER SYSTEM
// ============================================================================

function getCaliperScaling() {
  // Use import settings for uploaded images, regular settings for synthetic ECGs
  const speed = imageMode
    ? parseInt(document.getElementById('importSpeed')?.value || 25)
    : parseInt(document.getElementById('speed').value);
  const gain = imageMode
    ? parseInt(document.getElementById('importGain')?.value || 10)
    : parseInt(document.getElementById('gain').value);
  const pxmm = parseInt(document.getElementById('pxmm').value);
  const fs = ecgData?.fs || 1000;

  const pxPerSample = (pxmm * speed) / fs;
  const uvPerPx = 1000 / (pxmm * gain);

  return { pxPerSample, uvPerPx, fs, pxmm, speed, gain };
}

function snapToRPeak(x, tolerance = 15) {
  if (!document.getElementById('snapPeaks').checked) return x;
  if (!measurements?.rPeaks || !ecgData) return x;

  const { pxPerSample } = getCaliperScaling();
  const baseX = 40 + panOffset;

  for (const rIdx of measurements.rPeaks) {
    const peakX = baseX + rIdx * pxPerSample;
    if (Math.abs(peakX - x) < tolerance) {
      return peakX;
    }
  }
  return x;
}

function snapToGrid(x, y) {
  if (!document.getElementById('snapGrid').checked) return { x, y };
  const { pxmm } = getCaliperScaling();
  const gridSize = pxmm * 5; // 5mm grid
  return {
    x: Math.round(x / gridSize) * gridSize,
    y: Math.round(y / gridSize) * gridSize
  };
}

function constrainPoint(x, y, refX, refY, shiftHeld) {
  if (!shiftHeld) return { x, y };

  const dx = Math.abs(x - refX);
  const dy = Math.abs(y - refY);

  // Constrain to horizontal or vertical based on dominant direction
  if (dx > dy) {
    return { x, y: refY }; // Horizontal constraint
  } else {
    return { x: refX, y }; // Vertical constraint
  }
}

function calculateMeasurement(p1, p2) {
  const { pxPerSample, uvPerPx, fs, pxmm, speed, gain } = getCaliperScaling();

  const dx = Math.abs(p2.x - p1.x);
  const dy = p1.y - p2.y; // Inverted because canvas Y is down

  let dt_ms, dv_uv;

  if (imageMode) {
    // For uploaded images: use calibrated pxPerMm if available, otherwise estimate
    const actualPxPerMm = (imageCalibration?.calibrated && imageCalibration?.pxPerMm)
      ? imageCalibration.pxPerMm
      : pxmm; // Fallback to display setting (less accurate)

    // Time: dx pixels â†’ mm â†’ seconds â†’ ms
    const dx_mm = dx / actualPxPerMm;
    dt_ms = (dx_mm / speed) * 1000;

    // Voltage: dy pixels â†’ mm â†’ mV â†’ ÂµV
    const dy_mm = Math.abs(dy) / actualPxPerMm;
    dv_uv = (dy_mm / gain) * 1000 * Math.sign(dy);
  } else {
    // For synthetic ECGs: use sample-based calculation
    dt_ms = dx / pxPerSample / fs * 1000;
    dv_uv = dy * uvPerPx;
  }

  const rate_bpm = dt_ms > 0 ? 60000 / dt_ms : 0;

  return { dt_ms, dv_uv, rate_bpm };
}

function drawAllCalipers(ctx, w, h) {
  const { pxPerSample, uvPerPx, fs } = getCaliperScaling();

  // Draw completed measurements
  caliperMeasurements.forEach((m, idx) => {
    const isSelected = m.id === selectedCaliperId;
    drawSingleCaliper(ctx, m.p1, m.p2, m.color, isSelected, m.id);
  });

  // Draw in-progress measurement
  if (activeCaliperPoint && lastMousePos) {
    let endPoint = { ...lastMousePos };

    // Apply constraints
    if (shiftHeld) {
      endPoint = constrainPoint(endPoint.x, endPoint.y, activeCaliperPoint.x, activeCaliperPoint.y, true);
    }

    // Apply snapping
    endPoint.x = snapToRPeak(endPoint.x);
    if (document.getElementById('snapGrid').checked) {
      const snapped = snapToGrid(endPoint.x, endPoint.y);
      endPoint = snapped;
    }

    const color = CALIPER_COLORS[nextCaliperColor % CALIPER_COLORS.length];
    drawSingleCaliper(ctx, activeCaliperPoint, endPoint, color, true, null, true);
  }
}

function drawSingleCaliper(ctx, p1, p2, color, isSelected, id, isPreview = false) {
  const { dt_ms, dv_uv, rate_bpm } = calculateMeasurement(p1, p2);

  const lineWidth = isSelected ? 2.5 : 1.5;
  const handleSize = isSelected ? 7 : 5;
  const alpha = isPreview ? 0.7 : 1;

  ctx.save();
  ctx.globalAlpha = alpha;

  // Vertical lines at endpoints
  ctx.strokeStyle = color;
  ctx.lineWidth = lineWidth;
  ctx.setLineDash(isPreview ? [4, 4] : []);

  ctx.beginPath();
  ctx.moveTo(p1.x, p1.y - 35);
  ctx.lineTo(p1.x, p1.y + 35);
  ctx.moveTo(p2.x, p2.y - 35);
  ctx.lineTo(p2.x, p2.y + 35);
  ctx.stroke();

  // Horizontal connecting line
  const midY = (p1.y + p2.y) / 2;
  ctx.beginPath();
  ctx.moveTo(p1.x, midY);
  ctx.lineTo(p2.x, midY);
  ctx.stroke();

  // Arrow heads
  const arrowSize = 6;
  const leftX = Math.min(p1.x, p2.x);
  const rightX = Math.max(p1.x, p2.x);

  ctx.fillStyle = color;
  ctx.beginPath();
  ctx.moveTo(leftX, midY);
  ctx.lineTo(leftX + arrowSize, midY - arrowSize/2);
  ctx.lineTo(leftX + arrowSize, midY + arrowSize/2);
  ctx.fill();

  ctx.beginPath();
  ctx.moveTo(rightX, midY);
  ctx.lineTo(rightX - arrowSize, midY - arrowSize/2);
  ctx.lineTo(rightX - arrowSize, midY + arrowSize/2);
  ctx.fill();

  // Draggable handles (squares at endpoints)
  if (isSelected && !isPreview) {
    ctx.fillStyle = color;
    ctx.fillRect(p1.x - handleSize, p1.y - handleSize, handleSize * 2, handleSize * 2);
    ctx.fillRect(p2.x - handleSize, p2.y - handleSize, handleSize * 2, handleSize * 2);

    // White centers
    ctx.fillStyle = '#fff';
    ctx.fillRect(p1.x - handleSize + 2, p1.y - handleSize + 2, handleSize * 2 - 4, handleSize * 2 - 4);
    ctx.fillRect(p2.x - handleSize + 2, p2.y - handleSize + 2, handleSize * 2 - 4, handleSize * 2 - 4);
  }

  // Measurement label background
  const midX = (p1.x + p2.x) / 2;
  const labelY = Math.min(p1.y, p2.y) - 45;

  const mainLabel = `${Math.round(dt_ms)} ms`;
  const rateLabel = dt_ms > 100 ? ` (${Math.round(rate_bpm)} bpm)` : '';
  const ampLabel = Math.abs(dv_uv) > 50 ? `  Î”V: ${Math.round(dv_uv)} ÂµV` : '';
  const fullLabel = mainLabel + rateLabel + ampLabel;

  ctx.font = 'bold 13px system-ui';
  const textWidth = ctx.measureText(fullLabel).width;

  // Background pill
  ctx.fillStyle = isSelected ? color : 'rgba(255,255,255,0.95)';
  ctx.beginPath();
  ctx.roundRect(midX - textWidth/2 - 8, labelY - 10, textWidth + 16, 22, 6);
  ctx.fill();

  if (!isSelected) {
    ctx.strokeStyle = color;
    ctx.lineWidth = 1;
    ctx.stroke();
  }

  // Label text
  ctx.fillStyle = isSelected ? '#fff' : color;
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText(fullLabel, midX, labelY);

  ctx.restore();
  ctx.setLineDash([]);
}

function hitTestCaliperHandle(x, y) {
  const handleSize = 10;

  for (const m of caliperMeasurements) {
    if (Math.abs(x - m.p1.x) < handleSize && Math.abs(y - m.p1.y) < handleSize) {
      return { measurementId: m.id, handle: 'p1' };
    }
    if (Math.abs(x - m.p2.x) < handleSize && Math.abs(y - m.p2.y) < handleSize) {
      return { measurementId: m.id, handle: 'p2' };
    }
  }
  return null;
}

function hitTestCaliper(x, y) {
  for (const m of caliperMeasurements) {
    const minX = Math.min(m.p1.x, m.p2.x) - 5;
    const maxX = Math.max(m.p1.x, m.p2.x) + 5;
    const minY = Math.min(m.p1.y, m.p2.y) - 40;
    const maxY = Math.max(m.p1.y, m.p2.y) + 40;

    if (x >= minX && x <= maxX && y >= minY && y <= maxY) {
      return m.id;
    }
  }
  return null;
}

function updateCaliperList() {
  const container = document.getElementById('caliperItems');
  const listPanel = document.getElementById('caliperList');

  if (caliperMeasurements.length === 0) {
    listPanel.style.display = 'none';
    return;
  }

  listPanel.style.display = 'block';

  container.innerHTML = caliperMeasurements.map((m, idx) => {
    const { dt_ms, dv_uv, rate_bpm } = calculateMeasurement(m.p1, m.p2);
    const isSelected = m.id === selectedCaliperId;

    return `
      <div class="caliper-item ${isSelected ? 'active' : ''}" onclick="selectCaliper('${m.id}')" data-id="${m.id}">
        <div class="caliper-item-color" style="background:${m.color}"></div>
        <div class="caliper-item-values">
          <span>
            <span class="caliper-item-value">${Math.round(dt_ms)}</span>
            <span class="caliper-item-label">ms</span>
          </span>
          ${dt_ms > 100 ? `<span>
            <span class="caliper-item-value">${Math.round(rate_bpm)}</span>
            <span class="caliper-item-label">bpm</span>
          </span>` : ''}
          ${Math.abs(dv_uv) > 50 ? `<span>
            <span class="caliper-item-value">${Math.round(dv_uv)}</span>
            <span class="caliper-item-label">ÂµV</span>
          </span>` : ''}
        </div>
        <button class="caliper-item-delete" onclick="event.stopPropagation(); deleteCaliper('${m.id}')" title="Delete">Ã—</button>
      </div>
    `;
  }).join('');
}

window.selectCaliper = function(id) {
  selectedCaliperId = id === selectedCaliperId ? null : id;
  updateCaliperList();
  redraw();
};

window.deleteCaliper = function(id) {
  caliperMeasurements = caliperMeasurements.filter(m => m.id !== id);
  if (selectedCaliperId === id) selectedCaliperId = null;
  updateCaliperList();
  redraw();
};

function updateCaliperStatus(text) {
  const statusEl = document.getElementById('caliperStatus');
  if (statusEl) {
    statusEl.querySelector('span:last-child').textContent = text;
  }
}

window.toggleCalipers = function() {
  calipersActive = !calipersActive;
  const btn = document.getElementById('calBtn');
  const statusEl = document.getElementById('caliperStatus');

  btn.textContent = calipersActive ? 'Calipers: ON' : 'Calipers: OFF';
  btn.classList.toggle('primary', !calipersActive);
  document.getElementById('c').style.cursor = calipersActive ? 'crosshair' : 'default';

  // Show/hide floating status indicator
  if (calipersActive) {
    statusEl.classList.add('active');
    updateCaliperStatus('Caliper Mode: Click and drag to measure');
    document.getElementById('caliperList').style.display = 'block';
  } else {
    statusEl.classList.remove('active');
  }
};

window.clearAllCalipers = function() {
  caliperMeasurements = [];
  activeCaliperPoint = null;
  selectedCaliperId = null;
  draggingHandle = null;
  updateCaliperList();
  redraw();
};

// Canvas mouse events
const canvas = document.getElementById('c');

canvas.addEventListener('mousedown', (e) => {
  const rect = canvas.getBoundingClientRect();
  const x = e.clientX - rect.left;
  const y = e.clientY - rect.top;

  // Handle calibration mode
  if (calibrationMode && imageMode) {
    handleCalibrationClick(x, y);
    return;
  }

  if (!calipersActive) return;

  // Check for handle drag
  const handle = hitTestCaliperHandle(x, y);
  if (handle && handle.measurementId === selectedCaliperId) {
    draggingHandle = handle;
    canvas.style.cursor = 'grabbing';
    return;
  }

  // Check for caliper selection
  const hitId = hitTestCaliper(x, y);
  if (hitId) {
    selectedCaliperId = hitId;
    updateCaliperList();
    redraw();
    return;
  }

  // Start new measurement
  let snappedX = snapToRPeak(x);
  if (document.getElementById('snapGrid').checked) {
    const snapped = snapToGrid(snappedX, y);
    snappedX = snapped.x;
  }

  if (!activeCaliperPoint) {
    activeCaliperPoint = { x: snappedX, y };
    selectedCaliperId = null;
    updateCaliperStatus('Drag to second point, then release');
  }
});

canvas.addEventListener('mousemove', (e) => {
  const rect = canvas.getBoundingClientRect();
  const x = e.clientX - rect.left;
  const y = e.clientY - rect.top;

  lastMousePos = { x, y };

  if (draggingHandle) {
    const m = caliperMeasurements.find(m => m.id === draggingHandle.measurementId);
    if (m) {
      let newX = snapToRPeak(x);
      let newY = y;

      // Apply shift constraint relative to the OTHER point
      const otherPoint = draggingHandle.handle === 'p1' ? m.p2 : m.p1;
      if (shiftHeld) {
        const constrained = constrainPoint(newX, newY, otherPoint.x, otherPoint.y, true);
        newX = constrained.x;
        newY = constrained.y;
      }

      if (draggingHandle.handle === 'p1') {
        m.p1 = { x: newX, y: newY };
      } else {
        m.p2 = { x: newX, y: newY };
      }
      updateCaliperList();
      redraw();
    }
    return;
  }

  if (activeCaliperPoint) {
    redraw();
  }

  // Update cursor based on hover
  if (calipersActive && !activeCaliperPoint) {
    const handle = hitTestCaliperHandle(x, y);
    if (handle && handle.measurementId === selectedCaliperId) {
      canvas.style.cursor = 'grab';
    } else {
      canvas.style.cursor = 'crosshair';
    }
  }
});

canvas.addEventListener('mouseup', (e) => {
  if (draggingHandle) {
    draggingHandle = null;
    canvas.style.cursor = calipersActive ? 'crosshair' : 'default';
    return;
  }

  if (!calipersActive || !activeCaliperPoint) return;

  const rect = canvas.getBoundingClientRect();
  let x = e.clientX - rect.left;
  let y = e.clientY - rect.top;

  // Apply constraints and snapping
  if (shiftHeld) {
    const constrained = constrainPoint(x, y, activeCaliperPoint.x, activeCaliperPoint.y, true);
    x = constrained.x;
    y = constrained.y;
  }

  x = snapToRPeak(x);
  if (document.getElementById('snapGrid').checked) {
    const snapped = snapToGrid(x, y);
    x = snapped.x;
    y = snapped.y;
  }

  // Only create measurement if there's meaningful distance
  const dist = Math.hypot(x - activeCaliperPoint.x, y - activeCaliperPoint.y);
  if (dist > 5) {
    const color = CALIPER_COLORS[nextCaliperColor % CALIPER_COLORS.length];
    nextCaliperColor++;

    const measurement = {
      id: 'cal_' + Date.now(),
      p1: activeCaliperPoint,
      p2: { x, y },
      color
    };

    caliperMeasurements.push(measurement);
    selectedCaliperId = measurement.id;
    updateCaliperList();

    // Show success feedback briefly
    const { dt_ms } = calculateMeasurement(measurement.p1, measurement.p2);
    updateCaliperStatus(`Measured: ${Math.round(dt_ms)} ms â€” Click and drag to add more`);
  } else {
    updateCaliperStatus('Caliper Mode: Click and drag to measure');
  }

  activeCaliperPoint = null;
  redraw();
});

canvas.addEventListener('mouseleave', () => {
  if (draggingHandle) {
    draggingHandle = null;
  }
  lastMousePos = null;
  if (activeCaliperPoint) {
    redraw();
  }
});

// Keyboard shortcuts
document.addEventListener('keydown', (e) => {
  if (e.key === 'Shift') {
    shiftHeld = true;
  }

  if (document.activeElement.tagName === 'INPUT' || document.activeElement.tagName === 'SELECT') {
    return;
  }

  if (e.key === 'c' || e.key === 'C') {
    toggleCalipers();
  }

  if (e.key === 'Escape') {
    activeCaliperPoint = null;
    selectedCaliperId = null;
    updateCaliperList();
    if (calipersActive) {
      updateCaliperStatus('Caliper Mode: Click and drag to measure');
    }
    redraw();
  }

  if ((e.key === 'Delete' || e.key === 'Backspace') && selectedCaliperId) {
    deleteCaliper(selectedCaliperId);
  }
});

document.addEventListener('keyup', (e) => {
  if (e.key === 'Shift') {
    shiftHeld = false;
  }
});

// Touch event support for trackpad and touch devices
let touchStartPoint = null;

canvas.addEventListener('touchstart', (e) => {
  if (!calipersActive || e.touches.length !== 1) return;
  e.preventDefault();

  const touch = e.touches[0];
  const rect = canvas.getBoundingClientRect();
  const x = touch.clientX - rect.left;
  const y = touch.clientY - rect.top;

  // Check for caliper selection first
  const hitId = hitTestCaliper(x, y);
  if (hitId) {
    selectedCaliperId = hitId;
    updateCaliperList();
    redraw();
    return;
  }

  let snappedX = snapToRPeak(x);
  touchStartPoint = { x: snappedX, y };
  activeCaliperPoint = touchStartPoint;
  updateCaliperStatus('Drag to second point, then lift finger');
}, { passive: false });

canvas.addEventListener('touchmove', (e) => {
  if (!calipersActive || !touchStartPoint || e.touches.length !== 1) return;
  e.preventDefault();

  const touch = e.touches[0];
  const rect = canvas.getBoundingClientRect();
  lastMousePos = { x: touch.clientX - rect.left, y: touch.clientY - rect.top };
  redraw();
}, { passive: false });

canvas.addEventListener('touchend', (e) => {
  if (!calipersActive || !touchStartPoint) return;
  e.preventDefault();

  const touch = e.changedTouches[0];
  const rect = canvas.getBoundingClientRect();
  let x = touch.clientX - rect.left;
  let y = touch.clientY - rect.top;

  x = snapToRPeak(x);

  const dist = Math.hypot(x - touchStartPoint.x, y - touchStartPoint.y);
  if (dist > 20) {  // Slightly more forgiving threshold for touch
    const color = CALIPER_COLORS[nextCaliperColor % CALIPER_COLORS.length];
    nextCaliperColor++;

    const measurement = {
      id: 'cal_' + Date.now(),
      p1: touchStartPoint,
      p2: { x, y },
      color
    };

    caliperMeasurements.push(measurement);
    selectedCaliperId = measurement.id;
    updateCaliperList();

    const { dt_ms } = calculateMeasurement(measurement.p1, measurement.p2);
    updateCaliperStatus(`Measured: ${Math.round(dt_ms)} ms â€” Tap and drag to add more`);
  } else {
    updateCaliperStatus('Caliper Mode: Tap and drag to measure');
  }

  touchStartPoint = null;
  activeCaliperPoint = null;
  lastMousePos = null;
  redraw();
}, { passive: false });

// ============================================================================
// EXPORT FUNCTIONS
// ============================================================================

window.printWorksheet = function() {
  setMode('quiz');
  setTimeout(() => window.print(), 100);
};

window.printAnswerKey = function() {
  setMode('teach');
  setTimeout(() => window.print(), 100);
};

window.exportPNG = function() {
  const canvas = document.getElementById('c');
  const link = document.createElement('a');
  link.download = 'ecg-export.png';
  link.href = canvas.toDataURL('image/png');
  link.click();
};

window.exportJSON = function() {
  if (!ecgData && !imageMode) {
    showStatus('Generate or load an ECG first', 'error');
    return;
  }

  let exportData;

  if (imageMode && uploadedImage) {
    // Export teaching case with image
    const canvas = document.createElement('canvas');
    canvas.width = uploadedImage.width;
    canvas.height = uploadedImage.height;
    canvas.getContext('2d').drawImage(uploadedImage, 0, 0);

    exportData = {
      type: 'teaching_case',
      version: '1.0',
      source: {
        type: 'uploaded_image',
        filename: uploadedImageName,
        imageData: canvas.toDataURL('image/png'),
        width: uploadedImage.width,
        height: uploadedImage.height
      },
      calibration: {
        paperSpeed_mm_s: parseInt(document.getElementById('importSpeed')?.value || 25),
        gain_mm_mV: parseInt(document.getElementById('importGain')?.value || 10),
        scale_pxmm: parseInt(document.getElementById('pxmm')?.value || 4),
        pxPerMm: imageCalibration?.pxPerMm || null,
        calibrated: imageCalibration?.calibrated || false
      },
      measurements: caliperMeasurements.map(m => {
        const { dt_ms, dv_uv, rate_bpm } = calculateMeasurement(m.p1, m.p2);
        return {
          id: m.id,
          color: m.color,
          p1: m.p1,
          p2: m.p2,
          dt_ms: Math.round(dt_ms),
          dv_uv: Math.round(dv_uv),
          rate_bpm: Math.round(rate_bpm)
        };
      }),
      exportedAt: new Date().toISOString()
    };
  } else {
    // Export synthetic ECG
    exportData = ecgData;
  }

  const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
  const link = document.createElement('a');
  link.download = imageMode ? 'teaching-case.json' : 'ecg-export.json';
  link.href = URL.createObjectURL(blob);
  link.click();
  showStatus(imageMode ? 'Teaching case exported with measurements' : 'JSON exported', 'success', 2000);
};

window.exportCSV = function() {
  if (!ecgData) {
    showStatus('Generate or load an ECG first', 'error');
    return;
  }

  const leads = ecgData.leads_uV;
  const leadNames = Object.keys(leads);
  const len = leads[leadNames[0]].length;

  let csv = 'sample,' + leadNames.join(',') + '\n';
  for (let i = 0; i < len; i++) {
    csv += i + ',' + leadNames.map(l => leads[l][i]).join(',') + '\n';
  }

  const blob = new Blob([csv], { type: 'text/csv' });
  const link = document.createElement('a');
  link.download = 'ecg-export.csv';
  link.href = URL.createObjectURL(blob);
  link.click();
  showStatus('CSV exported', 'success', 2000);
};

// ============================================================================
// INITIALIZATION
// ============================================================================

window.redraw = redraw;

// Resize handling
window.addEventListener('resize', redraw);

// Initial draw
redraw();

// Generate initial case
generate();

</script>
</body>
</html>
